!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ADD_STR	data.c	1970;"	d	file:
ADD_STR	lex.c	2075;"	d	file:
ANIS_ERR	vario.c	1080;"	d	file:
ARGFLT	sem_main.c	60;"	d	file:
ARGINT	sem_main.c	61;"	d	file:
AT_GRIDMAP	predict.c	/^	AT_GRIDMAP$/;"	e	enum:__anon9	file:
AT_POINTS	predict.c	/^	AT_POINTS,$/;"	e	enum:__anon9	file:
BAD	polygon.c	425;"	d	file:
BAD	polygon.c	537;"	d	file:
BADCH	getopt.c	35;"	d	file:
BEGIN	lex.c	144;"	d	file:
BG_DEPTH	fig.c	76;"	d	file:
BINARY_NATIVE	mapio.c	192;"	d	file:
BINARY_NON_NATIVE	mapio.c	193;"	d	file:
C	gls.c	/^	MAT *C,        \/* (Generalized) Covariance matrix *\/$/;"	m	struct:__anon3	file:
CHECK_BITX	data.c	900;"	d	file:
CHECK_BITY	data.c	901;"	d	file:
CHECK_BITZ	data.c	902;"	d	file:
CHECK_CELLSIZE	mapio.c	187;"	d	file:
CHECK_COLS	mapio.c	186;"	d	file:
CHECK_ROWS	mapio.c	185;"	d	file:
CHECK_SUM	mapio.c	190;"	d	file:
CHECK_X_UL	mapio.c	188;"	d	file:
CHECK_Y_UL	mapio.c	189;"	d	file:
COLOR_OFFSET	fig.c	77;"	d	file:
COLOUR_TSIZE	map2gd.c	94;"	d	file:
CONDSIM	ui.c	/^static enum { VGM = 0, PRED, XVALID, CONDSIM } what = VGM;$/;"	e	enum:__anon13	file:
CROSS	polygon.c	76;"	d	file:
CROSS	polygon.c	804;"	d	file:
CSUSAGE	gstat.c	550;"	d	file:
CinvX	gls.c	/^		*CinvX,    \/* C-1 X *\/$/;"	m	struct:__anon3	file:
Command	ui.c	/^} Command;$/;"	t	typeref:struct:__anon14	file:
CsfReadRow	mapio.c	/^void CsfReadRow(GRIDMAP *m, float *buf, unsigned int row)$/;"	f
CsfWriteRow	mapio.c	/^void CsfWriteRow(GRIDMAP *m, float *buf, unsigned int row)$/;"	f
DATA2FIG_OPTIONS	map2fig.c	57;"	d	file:
DEFAULT_MISVAL	mapio.c	194;"	d	file:
DEFAULT_RADIUS	map2fig.c	69;"	d	file:
DEG2RAD	vario.c	1082;"	d	file:
DELTA_AB	polygon.c	89;"	d	file:
DPSWAP	select.c	60;"	d	file:
ECHO	lex.c	711;"	d	file:
EMSG	getopt.c	36;"	d	file:
EOB_ACT_CONTINUE_SCAN	lex.c	187;"	d	file:
EOB_ACT_END_OF_FILE	lex.c	188;"	d	file:
EOB_ACT_LAST_MATCH	lex.c	189;"	d	file:
EPOINT1	polygon.c	79;"	d	file:
EPOINT1	polygon.c	807;"	d	file:
EPOINT2	polygon.c	808;"	d	file:
EPOINT2	polygon.c	80;"	d	file:
ER_IMPOSVAL	random.c	66;"	d	file:
EVFMT	sem.c	877;"	d	file:
EXTDBASE_LINK	ext_dbase.c	/^} EXTDBASE_LINK;$/;"	t	typeref:struct:__anon2	file:
ErrMsg	random.c	67;"	d	file:
FIGXMAX	fig.c	60;"	d	file:
FIGXMIN	fig.c	59;"	d	file:
FIGYMAX	fig.c	62;"	d	file:
FIGYMIN	fig.c	61;"	d	file:
FIG_HEADER	fig.c	44;"	d	file:
FILE_RECORD	utils.c	/^} FILE_RECORD;$/;"	t	typeref:struct:__anon18	file:
FILE_STATUS	utils.c	/^typedef enum { IS_OPEN, IS_CLOSED, IS_REMOVED } FILE_STATUS;$/;"	t	typeref:enum:__anon17	file:
FILE_TYPE	utils.c	/^typedef enum { IS_FILE, IS_PIPE } FILE_TYPE;$/;"	t	typeref:enum:__anon16	file:
FILL_TABLE	parse.c	2905;"	d	file:
FIT_LOG	fit.c	51;"	d	file:
FLEXINT_H	lex.c	48;"	d	file:
FLEX_BETA	lex.c	32;"	d	file:
FLEX_SCANNER	lex.c	27;"	d	file:
FLT_MAX	read.c	58;"	d	file:
FLT_MIN	read.c	59;"	d	file:
FONT_POINT	fig.c	75;"	d	file:
FP_ERR	userio.c	374;"	d	file:
FSWRITE	writecmd.c	186;"	d	file:
FWRITE	writecmd.c	177;"	d	file:
Float	msim.c	/^typedef double Float; \/* doubles the memory requirement -> may be pretty much *\/$/;"	t	file:
Float	msim.c	/^typedef float Float;$/;"	t	file:
GET_BLU	palet.c	69;"	d	file:
GET_GRE	palet.c	68;"	d	file:
GET_RED	palet.c	67;"	d	file:
GET_STRING	ui.c	102;"	d	file:
GET_STRING	ui.c	104;"	d	file:
GEZERO	parse.c	/^		GEZERO, $/;"	e	enum:__anon5::__anon7	file:
GLM	gls.c	/^} GLM; \/* structure is locally defined, will be held in void *glm in DATA *\/$/;"	t	typeref:struct:__anon3	file:
GNUPLOT_TERM	plot.c	/^} GNUPLOT_TERM;$/;"	t	typeref:struct:__anon8	file:
GSTAT_EXPR	parse.c	/^} GSTAT_EXPR;$/;"	t	typeref:struct:__anon5	file:
GTZERO	parse.c	/^		GTZERO $/;"	e	enum:__anon5::__anon7	file:
GetRGB	palet.c	/^float *GetRGB(PALETTE palet, float pos, float maxcol) {$/;"	f
HELP	gstat.c	117;"	d	file:
HUGE_VAL	read.c	62;"	d	file:
IDENT	parse.c	/^     IDENT = 262,$/;"	e	enum:yytokentype	file:
IDENT	parse.c	253;"	d	file:
ID_AREA	parse.c	/^     ID_AREA = 274,$/;"	e	enum:yytokentype	file:
ID_AREA	parse.c	265;"	d	file:
ID_BLOCK	parse.c	/^     ID_BLOCK = 275,$/;"	e	enum:yytokentype	file:
ID_BLOCK	parse.c	266;"	d	file:
ID_BOUNDS	parse.c	/^     ID_BOUNDS = 277,$/;"	e	enum:yytokentype	file:
ID_BOUNDS	parse.c	268;"	d	file:
ID_COVARIANCES	parse.c	/^     ID_COVARIANCES = 268,$/;"	e	enum:yytokentype	file:
ID_COVARIANCES	parse.c	259;"	d	file:
ID_DATA	parse.c	/^     ID_DATA = 263,$/;"	e	enum:yytokentype	file:
ID_DATA	parse.c	254;"	d	file:
ID_EDGES	parse.c	/^     ID_EDGES = 271,$/;"	e	enum:yytokentype	file:
ID_EDGES	parse.c	262;"	d	file:
ID_MARGINALS	parse.c	/^     ID_MARGINALS = 278$/;"	e	enum:yytokentype	file:
ID_MARGINALS	parse.c	269;"	d	file:
ID_MASKS	parse.c	/^     ID_MASKS = 270,$/;"	e	enum:yytokentype	file:
ID_MASKS	parse.c	261;"	d	file:
ID_MERGE	parse.c	/^     ID_MERGE = 273,$/;"	e	enum:yytokentype	file:
ID_MERGE	parse.c	264;"	d	file:
ID_METHOD	parse.c	/^     ID_METHOD = 276,$/;"	e	enum:yytokentype	file:
ID_METHOD	parse.c	267;"	d	file:
ID_OUTPUT	parse.c	/^     ID_OUTPUT = 269,$/;"	e	enum:yytokentype	file:
ID_OUTPUT	parse.c	260;"	d	file:
ID_PREDICTIONS	parse.c	/^     ID_PREDICTIONS = 266,$/;"	e	enum:yytokentype	file:
ID_PREDICTIONS	parse.c	257;"	d	file:
ID_SET	parse.c	/^     ID_SET = 272,$/;"	e	enum:yytokentype	file:
ID_SET	parse.c	263;"	d	file:
ID_VARIANCES	parse.c	/^     ID_VARIANCES = 267,$/;"	e	enum:yytokentype	file:
ID_VARIANCES	parse.c	258;"	d	file:
ID_VARIOGRAM	parse.c	/^     ID_VARIOGRAM = 265,$/;"	e	enum:yytokentype	file:
ID_VARIOGRAM	parse.c	256;"	d	file:
ID_X	parse.c	/^     ID_X = 264,$/;"	e	enum:yytokentype	file:
ID_X	parse.c	255;"	d	file:
INCLUDED_DATA	ext_dbase.c	20;"	d	file:
INCLUDED_DEBUG	ext_dbase.c	30;"	d	file:
INCLUDED_DEFS	ext_dbase.c	3;"	d	file:
INCLUDED_EXT_DBASE	data.c	57;"	d	file:
INCLUDED_EXT_DBASE	ext_dbase.c	25;"	d	file:
INCLUDED_PQDB_CAPI	ext_dbase.c	35;"	d	file:
INCLUDED_USERIO	ext_dbase.c	16;"	d	file:
INCLUDED_UTILS	ext_dbase.c	12;"	d	file:
INCR	utils.c	396;"	d	file:
INITIAL	lex.c	619;"	d	file:
INIT_C	random.c	469;"	d	file:
INIT_CD	random.c	470;"	d	file:
INIT_CM	random.c	471;"	d	file:
INT	parse.c	/^     INT = 258,$/;"	e	enum:yytokentype	file:
INT	parse.c	249;"	d	file:
INT16_MAX	lex.c	90;"	d	file:
INT16_MIN	lex.c	81;"	d	file:
INT32_MAX	lex.c	93;"	d	file:
INT32_MIN	lex.c	84;"	d	file:
INT8_MAX	lex.c	87;"	d	file:
INT8_MIN	lex.c	78;"	d	file:
INT_MAX	read.c	50;"	d	file:
INT_MIN	read.c	51;"	d	file:
IN_OUT	polygon.c	472;"	d	file:
IN_OUT	polygon.c	536;"	d	file:
IS_CLASSIFIED	map2gd.c	88;"	d	file:
IS_CLASSIFIED	map2gd.c	92;"	d	file:
IS_CLOSED	utils.c	/^typedef enum { IS_OPEN, IS_CLOSED, IS_REMOVED } FILE_STATUS;$/;"	e	enum:__anon17	file:
IS_D_VECTOR	parse.c	/^		IS_D_VECTOR, $/;"	e	enum:__anon5::__anon6	file:
IS_FILE	utils.c	/^typedef enum { IS_FILE, IS_PIPE } FILE_TYPE;$/;"	e	enum:__anon16	file:
IS_INT	parse.c	/^		IS_INT, $/;"	e	enum:__anon5::__anon6	file:
IS_OPEN	utils.c	/^typedef enum { IS_OPEN, IS_CLOSED, IS_REMOVED } FILE_STATUS;$/;"	e	enum:__anon17	file:
IS_PIPE	utils.c	/^typedef enum { IS_FILE, IS_PIPE } FILE_TYPE;$/;"	e	enum:__anon16	file:
IS_REAL	parse.c	/^		IS_REAL, $/;"	e	enum:__anon5::__anon6	file:
IS_REMOVED	utils.c	/^typedef enum { IS_OPEN, IS_CLOSED, IS_REMOVED } FILE_STATUS;$/;"	e	enum:__anon17	file:
IS_STRING	parse.c	/^		IS_STRING, $/;"	e	enum:__anon5::__anon6	file:
IS_UINT	parse.c	/^		IS_UINT, $/;"	e	enum:__anon5::__anon6	file:
IS_VAR	xvalid.c	46;"	d	file:
IWW	polygon.c	812;"	d	file:
IWW	polygon.c	86;"	d	file:
IminAw	reml.c	/^static MAT *IminAw = MNULL;$/;"	v	file:
InPoly	polygon.c	/^static char InPoly(PLOT_POINT q, POLYGON *Poly)$/;"	f	file:
KEY_MOUSE	ui.c	117;"	d	file:
LEGSIZEX	map2gd.c	77;"	d	file:
LEGSIZEY	map2gd.c	78;"	d	file:
LEGSIZX	fig.c	69;"	d	file:
LEGSIZY	fig.c	70;"	d	file:
LEGSKIP	fig.c	72;"	d	file:
LEGXMAX	fig.c	65;"	d	file:
LEGXMIN	fig.c	64;"	d	file:
LEGYMAX	fig.c	67;"	d	file:
LEGYMIN	fig.c	66;"	d	file:
LENGTHOF	ui.c	70;"	d	file:
LONG_MAX	read.c	54;"	d	file:
LONG_MIN	read.c	55;"	d	file:
MANTISSA_SIZE	random.c	467;"	d	file:
MAXCHAR	lex.c	2076;"	d	file:
MAXCOL	map2gd.c	82;"	d	file:
MAXCOL	palet.c	53;"	d	file:
MAX_ANG	direct.c	151;"	d	file:
MAX_ANG	direct.c	44;"	d	file:
MAX_FIT	ui.c	1019;"	d	file:
MAX_OPTION	ui.c	175;"	d	file:
MAX_SAMPLE	sample.c	47;"	d	file:
MAX_SIZE	utils.c	794;"	d	file:
MEM_ERR	userio.c	367;"	d	file:
MINMAX	map2fig.c	70;"	d	file:
MIN_BESS	vario_fn.c	52;"	d	file:
MY_input	lex.c	/^int MY_input(void) {$/;"	f
MY_output	lex.c	/^int MY_output(int c) {$/;"	f
MY_unput	lex.c	/^int MY_unput(int c) {$/;"	f
M_DEBUG	gls.c	89;"	d	file:
My_yy_lineno	lex.c	/^static int yy_Lexpos = 0, yy_Posafternl = 1, My_yy_lineno = 1,$/;"	v	file:
NEARLY_ZERO	fit.c	52;"	d	file:
NOLIMIT	parse.c	/^		NOLIMIT, $/;"	e	enum:__anon5::__anon7	file:
NO_ARG	parse.c	/^		NO_ARG $/;"	e	enum:__anon5::__anon6	file:
N_NODES	nsearch.c	74;"	d	file:
N_PTS	plot.c	48;"	d	file:
N_WIND	ui.c	91;"	d	file:
OPTIONS	map2gd.c	61;"	d	file:
OSSFIM_HELPSTRING	ossfim.c	99;"	d	file:
P	random.c	463;"	d	file:
PAL	palet.c	/^} PAL;$/;"	t	typeref:struct:__anon4	file:
PALETUSAGE	palet.c	55;"	d	file:
PI	vario_fn.c	54;"	d	file:
PLOT_WINDOW_NR	plot.c	49;"	d	file:
PM1	random.c	464;"	d	file:
POLY_EDGE	polygon.c	811;"	d	file:
POLY_EDGE	polygon.c	85;"	d	file:
POLY_IN	polygon.c	809;"	d	file:
POLY_IN	polygon.c	83;"	d	file:
POLY_OUT	polygon.c	810;"	d	file:
POLY_OUT	polygon.c	84;"	d	file:
POWDI	gcdist.c	11;"	d	file:
POWDI	gcdist.c	9;"	d	file:
PRED	ui.c	/^static enum { VGM = 0, PRED, XVALID, CONDSIM } what = VGM;$/;"	e	enum:__anon13	file:
PRED_AT	predict.c	/^} PRED_AT;$/;"	t	typeref:enum:__anon9	file:
PROTECT	s.c	53;"	d	file:
PR_DOUBLE	ui.c	/^typedef enum PR_TYPE { PR_INT, PR_DOUBLE, PR_STRING, PR_YN } PR_TYPE ;$/;"	e	enum:PR_TYPE	file:
PR_INT	ui.c	/^typedef enum PR_TYPE { PR_INT, PR_DOUBLE, PR_STRING, PR_YN } PR_TYPE ;$/;"	e	enum:PR_TYPE	file:
PR_STRING	ui.c	/^typedef enum PR_TYPE { PR_INT, PR_DOUBLE, PR_STRING, PR_YN } PR_TYPE ;$/;"	e	enum:PR_TYPE	file:
PR_TYPE	ui.c	/^typedef enum PR_TYPE { PR_INT, PR_DOUBLE, PR_STRING, PR_YN } PR_TYPE ;$/;"	g	file:
PR_TYPE	ui.c	/^typedef enum PR_TYPE { PR_INT, PR_DOUBLE, PR_STRING, PR_YN } PR_TYPE ;$/;"	t	typeref:enum:PR_TYPE	file:
PR_YN	ui.c	/^typedef enum PR_TYPE { PR_INT, PR_DOUBLE, PR_STRING, PR_YN } PR_TYPE ;$/;"	e	enum:PR_TYPE	file:
PTS	sample.c	/^} PTS;$/;"	t	typeref:struct:__anon11	file:
PTS_LIST	sample.c	/^} PTS_LIST;$/;"	t	typeref:struct:__anon12	file:
Q	random.c	465;"	d	file:
QSTR	parse.c	/^     QSTR = 261,$/;"	e	enum:yytokentype	file:
QSTR	parse.c	252;"	d	file:
Q_HELP	pqueue.c	250;"	d	file:
RANDIN	s.c	45;"	d	file:
RANDIN	s.c	57;"	d	file:
RANDOM_REALS	random.c	468;"	d	file:
RANDOUT	s.c	46;"	d	file:
RANDOUT	s.c	58;"	d	file:
REAL	parse.c	/^     REAL = 260,$/;"	e	enum:yytokentype	file:
REAL	parse.c	251;"	d	file:
REJECT	lex.c	507;"	d	file:
RGB	palet.c	/^	int *RGB;$/;"	m	struct:__anon4	file:
R_NORMAL	s.c	44;"	d	file:
R_NORMAL	s.c	56;"	d	file:
R_UNIFORM	s.c	43;"	d	file:
R_UNIFORM	s.c	55;"	d	file:
Rprintf	s.c	59;"	d	file:
SAMPLE_USAGE	sample.c	65;"	d	file:
SCANNED	lex.c	608;"	d	file:
SCANNED	lex.c	611;"	d	file:
SEM_INCREMENT	sem.c	62;"	d	file:
SEXP	s.c	52;"	d	file:
SHORTHELP0	ui.c	71;"	d	file:
SHORTHELP1	ui.c	73;"	d	file:
SING_ERR	userio.c	363;"	d	file:
SIZE	plot.c	47;"	d	file:
SLOW	data.c	1387;"	d	file:
SM_DEBUG	gls.c	98;"	d	file:
SPOINT1	polygon.c	77;"	d	file:
SPOINT1	polygon.c	805;"	d	file:
SPOINT2	polygon.c	78;"	d	file:
SPOINT2	polygon.c	806;"	d	file:
STATE_SIZE	random.c	466;"	d	file:
STRATUM	predict.c	86;"	d	file:
STRLEN	ui.c	167;"	d	file:
SURFER_MISVAL	mapio.c	195;"	d	file:
SWAP_M_N	mapio.c	182;"	d	file:
SWAP_N	mapio.c	181;"	d	file:
S_EVALUATOR	s.c	47;"	d	file:
S_no_progress	s.c	/^static void S_no_progress(unsigned int current, unsigned int total) {$/;"	f	file:
TABLE_SIZE	map2gd.c	84;"	d	file:
TABLE_SIZE	parse.c	2902;"	d	file:
TEXTSKIP	fig.c	73;"	d	file:
TICKSHEIGHT	map2gd.c	79;"	d	file:
TICKSWIDTH	map2gd.c	80;"	d	file:
TOFIGX	fig.c	79;"	d	file:
TOFIGY	fig.c	81;"	d	file:
UINT	parse.c	/^     UINT = 259,$/;"	e	enum:yytokentype	file:
UINT	parse.c	250;"	d	file:
UINT16_MAX	lex.c	99;"	d	file:
UINT32_MAX	lex.c	102;"	d	file:
UINT8_MAX	lex.c	96;"	d	file:
UNKNOWN	parse.c	/^		UNKNOWN, $/;"	e	enum:__anon5::__anon6	file:
UNPROTECT	s.c	54;"	d	file:
UPDATE_BLP	gls.c	93;"	d	file:
UPDATE_BLUP	gls.c	94;"	d	file:
VGM	ui.c	/^static enum { VGM = 0, PRED, XVALID, CONDSIM } what = VGM;$/;"	e	enum:__anon13	file:
V_DEBUG	gls.c	91;"	d	file:
WPWARNING	msim.c	206;"	d	file:
X	gls.c	/^		*X,        \/* design matrix, y = X beta + e *\/$/;"	m	struct:__anon3	file:
X1	ext_dbase.c	/^static double X1=1.0;$/;"	v	file:
XCinvX	gls.c	/^		*XCinvX;   \/* X' C-1 X *\/$/;"	m	struct:__anon3	file:
XVALID	ui.c	/^static enum { VGM = 0, PRED, XVALID, CONDSIM } what = VGM;$/;"	e	enum:__anon13	file:
XVXt_mlt	reml.c	/^MAT *XVXt_mlt(MAT *X, MAT *V, MAT *out) {$/;"	f
XYV	ext_dbase.c	/^} XYV;$/;"	t	typeref:struct:__anon1	file:
XdXt_mlt	reml.c	/^MAT *XdXt_mlt(MAT *X, VEC *d, MAT *out) {$/;"	f
Xmax	fig.c	/^static double Xmin, Xmax, Ymin, Ymax;$/;"	v	file:
Xmin	fig.c	/^static double Xmin, Xmax, Ymin, Ymax;$/;"	v	file:
XtVX_mlt	reml.c	/^MAT *XtVX_mlt(MAT *X, MAT *V, MAT *out) {$/;"	f
XtdX_mlt	reml.c	/^MAT *XtdX_mlt(MAT *X, VEC *d, MAT *out) {$/;"	f
YYABORT	parse.c	930;"	d	file:
YYACCEPT	parse.c	929;"	d	file:
YYBACKUP	parse.c	942;"	d	file:
YYBISON	parse.c	46;"	d	file:
YYBISON_VERSION	parse.c	49;"	d	file:
YYCOPY	parse.c	481;"	d	file:
YYCOPY	parse.c	484;"	d	file:
YYDEBUG	parse.c	202;"	d	file:
YYDPRINTF	parse.c	1022;"	d	file:
YYDPRINTF	parse.c	1171;"	d	file:
YYEMPTY	parse.c	926;"	d	file:
YYEOF	parse.c	927;"	d	file:
YYERRCODE	parse.c	961;"	d	file:
YYERROR	parse.c	931;"	d	file:
YYERROR_VERBOSE	parse.c	207;"	d	file:
YYERROR_VERBOSE	parse.c	208;"	d	file:
YYERROR_VERBOSE	parse.c	210;"	d	file:
YYFAIL	parse.c	938;"	d	file:
YYFINAL	parse.c	514;"	d	file:
YYFPRINTF	parse.c	1019;"	d	file:
YYFREE	parse.c	447;"	d	file:
YYID	parse.c	/^YYID (int yyi)$/;"	f	file:
YYID	parse.c	371;"	d	file:
YYINITDEPTH	parse.c	1180;"	d	file:
YYLAST	parse.c	516;"	d	file:
YYLEX	parse.c	1009;"	d	file:
YYLEX	parse.c	1011;"	d	file:
YYLLOC_DEFAULT	parse.c	970;"	d	file:
YYLSP_NEEDED	parse.c	64;"	d	file:
YYMALLOC	parse.c	440;"	d	file:
YYMAXDEPTH	parse.c	1191;"	d	file:
YYMAXUTOK	parse.c	529;"	d	file:
YYNNTS	parse.c	521;"	d	file:
YYNRULES	parse.c	523;"	d	file:
YYNSTATES	parse.c	525;"	d	file:
YYNTOKENS	parse.c	519;"	d	file:
YYPACT_NINF	parse.c	778;"	d	file:
YYPOPSTACK	parse.c	1531;"	d	file:
YYPULL	parse.c	61;"	d	file:
YYPURE	parse.c	55;"	d	file:
YYPUSH	parse.c	58;"	d	file:
YYRECOVERING	parse.c	940;"	d	file:
YYRHSLOC	parse.c	968;"	d	file:
YYSIZE_MAXIMUM	parse.c	348;"	d	file:
YYSIZE_T	parse.c	336;"	d	file:
YYSIZE_T	parse.c	338;"	d	file:
YYSIZE_T	parse.c	342;"	d	file:
YYSIZE_T	parse.c	344;"	d	file:
YYSKELETON_NAME	parse.c	52;"	d	file:
YYSTACK_ALLOC	parse.c	394;"	d	file:
YYSTACK_ALLOC	parse.c	398;"	d	file:
YYSTACK_ALLOC	parse.c	403;"	d	file:
YYSTACK_ALLOC	parse.c	426;"	d	file:
YYSTACK_ALLOC_MAXIMUM	parse.c	423;"	d	file:
YYSTACK_ALLOC_MAXIMUM	parse.c	429;"	d	file:
YYSTACK_BYTES	parse.c	473;"	d	file:
YYSTACK_FREE	parse.c	417;"	d	file:
YYSTACK_FREE	parse.c	427;"	d	file:
YYSTACK_GAP_MAXIMUM	parse.c	469;"	d	file:
YYSTACK_RELOCATE	parse.c	500;"	d	file:
YYSTATE	lex.c	151;"	d	file:
YYSTYPE	parse.c	/^typedef union YYSTYPE$/;"	u	file:
YYSTYPE	parse.c	/^} YYSTYPE;$/;"	t	typeref:union:YYSTYPE	file:
YYSTYPE_IS_DECLARED	parse.c	293;"	d	file:
YYSTYPE_IS_TRIVIAL	parse.c	291;"	d	file:
YYTABLES_NAME	lex.c	2012;"	d	file:
YYTABLE_NINF	parse.c	823;"	d	file:
YYTERROR	parse.c	960;"	d	file:
YYTOKENTYPE	parse.c	221;"	d	file:
YYTOKEN_TABLE	parse.c	215;"	d	file:
YYTRANSLATE	parse.c	531;"	d	file:
YYUNDEFTOK	parse.c	528;"	d	file:
YYUSE	parse.c	364;"	d	file:
YYUSE	parse.c	366;"	d	file:
YY_	parse.c	354;"	d	file:
YY_	parse.c	358;"	d	file:
YY_AT_BOL	lex.c	358;"	d	file:
YY_BREAK	lex.c	790;"	d	file:
YY_BUFFER_EOF_PENDING	lex.c	274;"	d	file:
YY_BUFFER_NEW	lex.c	262;"	d	file:
YY_BUFFER_NORMAL	lex.c	263;"	d	file:
YY_BUFFER_STATE	lex.c	/^typedef struct yy_buffer_state *YY_BUFFER_STATE;$/;"	t	typeref:struct:yy_buffer_state	file:
YY_BUF_SIZE	lex.c	168;"	d	file:
YY_BUF_SIZE	lex.c	170;"	d	file:
YY_CHAR	lex.c	/^typedef unsigned char YY_CHAR;$/;"	t	file:
YY_CURRENT_BUFFER	lex.c	290;"	d	file:
YY_CURRENT_BUFFER_LVALUE	lex.c	297;"	d	file:
YY_DECL	lex.c	778;"	d	file:
YY_DECL_IS_OURS	lex.c	774;"	d	file:
YY_DO_BEFORE_ACTION	lex.c	383;"	d	file:
YY_END_OF_BUFFER	lex.c	391;"	d	file:
YY_END_OF_BUFFER_CHAR	lex.c	159;"	d	file:
YY_EXIT_FAILURE	lex.c	1810;"	d	file:
YY_EXTRA_TYPE	lex.c	630;"	d	file:
YY_FATAL_ERROR	lex.c	765;"	d	file:
YY_FLEX_MAJOR_VERSION	lex.c	28;"	d	file:
YY_FLEX_MINOR_VERSION	lex.c	29;"	d	file:
YY_FLEX_SUBMINOR_VERSION	lex.c	30;"	d	file:
YY_FLUSH_BUFFER	lex.c	326;"	d	file:
YY_INPUT	lex.c	586;"	d	file:
YY_INPUT	lex.c	587;"	d	file:
YY_INPUT	lex.c	718;"	d	file:
YY_INT_ALIGNED	lex.c	4;"	d	file:
YY_LESS_LINENO	lex.c	191;"	d	file:
YY_LOCATION_PRINT	parse.c	1001;"	d	file:
YY_LOCATION_PRINT	parse.c	996;"	d	file:
YY_MORE_ADJ	lex.c	509;"	d	file:
YY_NEW_FILE	lex.c	157;"	d	file:
YY_NULL	lex.c	131;"	d	file:
YY_NUM_RULES	lex.c	390;"	d	file:
YY_READ_BUF_SIZE	lex.c	700;"	d	file:
YY_READ_BUF_SIZE	lex.c	702;"	d	file:
YY_REDUCE_PRINT	parse.c	1161;"	d	file:
YY_REDUCE_PRINT	parse.c	1174;"	d	file:
YY_RESTORE_YY_MORE_OFFSET	lex.c	510;"	d	file:
YY_RULE_SETUP	lex.c	793;"	d	file:
YY_SC_TO_UI	lex.c	138;"	d	file:
YY_STACK_PRINT	parse.c	1123;"	d	file:
YY_STACK_PRINT	parse.c	1173;"	d	file:
YY_START	lex.c	150;"	d	file:
YY_START_STACK_INCR	lex.c	760;"	d	file:
YY_STATE_BUF_SIZE	lex.c	176;"	d	file:
YY_STATE_EOF	lex.c	154;"	d	file:
YY_STRUCT_YY_BUFFER_STATE	lex.c	215;"	d	file:
YY_SYMBOL_PRINT	parse.c	1028;"	d	file:
YY_SYMBOL_PRINT	parse.c	1172;"	d	file:
YY_TYPEDEF_YY_BUFFER_STATE	lex.c	179;"	d	file:
YY_TYPEDEF_YY_SIZE_T	lex.c	210;"	d	file:
YY_USER_ACTION	lex.c	785;"	d	file:
YY_USE_CONST	lex.c	112;"	d	file:
YY_USE_CONST	lex.c	119;"	d	file:
Ymax	fig.c	/^static double Xmin, Xmax, Ymin, Ymax;$/;"	v	file:
Ymin	fig.c	/^static double Xmin, Xmax, Ymin, Ymax;$/;"	v	file:
Z_EPSILON	random.c	260;"	d	file:
Z_MAX	random.c	261;"	d	file:
_STDLIB_H	parse.c	408;"	d	file:
_STDLIB_H	parse.c	436;"	d	file:
__STDC_LIMIT_MACROS	lex.c	58;"	d	file:
__STDC__	parse.c	158;"	d	file:
__errno	gstat.c	/^int __errno;$/;"	v
add_to_pts_list	sample.c	/^static PTS_LIST *add_to_pts_list(int row_offset, int col_offset, $/;"	f	file:
all_directions	direct.c	/^static int all_directions = -1;$/;"	v	file:
alloc_exp_variogram	sem.c	/^static SAMPLE_VGM *alloc_exp_variogram(DATA *a, DATA *b, SAMPLE_VGM *ev) {$/;"	f	file:
alloc_mv_grid	mapio.c	/^static void alloc_mv_grid(GRIDMAP * m)$/;"	f	file:
alloca	parse.c	401;"	d	file:
allow_vector_only	parse.c	/^	vector_only = 0, allow_vector_only = 0;$/;"	v	file:
almost_equals	utils.c	/^int almost_equals(const char *tok, const char *str) {$/;"	f
alpha	direct.c	/^static double alpha = 0.0, beta = 0.0,$/;"	v	file:
anis	parse.c	/^static double range[NRANGEPARS], anis[5];$/;"	v	file:
argv0	glvars.c	/^char *argv0;$/;"	v
attroff	ui.c	112;"	d	file:
attroff	ui.c	113;"	d	file:
attron	ui.c	110;"	d	file:
attron	ui.c	111;"	d	file:
attrset	ui.c	108;"	d	file:
attrset	ui.c	109;"	d	file:
average_duplicates	data.c	/^static int average_duplicates(DATA *d) { $/;"	f	file:
bbox_from_data	nsearch.c	/^static BBOX bbox_from_data(DATA *d) {$/;"	f	file:
bbox_from_grid	nsearch.c	/^static BBOX bbox_from_grid(const GRIDMAP *gt, const DATA_GRIDMAP *dg) {$/;"	f	file:
bessi1	vario_fn.c	/^static double bessi1(double x)$/;"	f	file:
bessk1	vario_fn.c	/^static double bessk1(double x)$/;"	f	file:
beta	direct.c	/^static double alpha = 0.0, beta = 0.0,$/;"	v	file:
beta	gls.c	/^		*beta;     \/* parameter vector *\/$/;"	m	struct:__anon3	file:
beta	msim.c	/^	***beta = NULL;$/;"	v	file:
block	glvars.c	/^static DPOINT block;$/;"	v	file:
block_discr	block.c	/^DATA *block_discr(DATA *d, const DPOINT *block, const DPOINT *where) {$/;"	f
boundary_file	parse.c	/^static char **ofn = NULL, *boundary_file = NULL;$/;"	v	file:
bp	parse.c	/^static DPOINT *bp = NULL;$/;"	v	file:
bquote	lex.c	/^static char *bquote(char *command) {$/;"	f	file:
c	random.c	/^static double c, cd, cm;$/;"	v	file:
c	sample.c	/^	int r, c;$/;"	m	struct:__anon11	file:
calc_VinvIminAw	reml.c	/^static MAT *calc_VinvIminAw(MAT *Vw, MAT *X, MAT *VinvIminAw, int calc_Aw) {$/;"	f	file:
calc_data_mean_std	data.c	/^static void calc_data_mean_std(DATA *d) {$/;"	f	file:
calc_ll	reml.c	/^static double calc_ll(MAT *Vw, MAT *X, VEC *y, int n) {$/;"	f	file:
calc_lm	lm.c	/^LM *calc_lm(LM *lm) {$/;"	f
calc_mu	lm.c	/^double calc_mu(const DATA *d, const DPOINT *where) {$/;"	f
calc_poly	getest.c	/^static void calc_poly(DPOINT *where, double *est) {$/;"	f	file:
calc_polynomial	data.c	/^double calc_polynomial(DPOINT *p, int colX) {$/;"	f
calc_polynomial_point	data.c	/^void calc_polynomial_point(DATA *d, DPOINT *pt) {$/;"	f
calc_polynomials	data.c	/^void calc_polynomials(DATA *d) {$/;"	f
calc_progress	ui.c	/^void calc_progress(unsigned int step, unsigned int max_step) {$/;"	f
calc_r	stat.c	/^void calc_r(double *a, double *b, int n, double *corr) {$/;"	f
calc_rhs_Tr_m	reml.c	/^static void calc_rhs_Tr_m(int n_models, MAT **Vk,MAT *VinvIminAw, $/;"	f	file:
calc_stats	gstat.c	/^static int calc_stats(int argc, char *argv[]) {$/;"	f	file:
calc_variogram	sem.c	/^int calc_variogram(VARIOGRAM *v \/* pointer to VARIOGRAM structure *\/,$/;"	f
calc_vgm	ui.c	/^int calc_vgm(VARIOGRAM *v, char *name) {$/;"	f
cd	random.c	/^static double c, cd, cm;$/;"	v	file:
cdf_read_grd_info	mapio.c	/^static int cdf_read_grd_info(GRIDMAP * m, double *x_max, double *y_min,$/;"	f	file:
centre_area	data.c	/^void centre_area(DATA *area) {$/;"	f
check_assign_expr	parse.c	/^static void check_assign_expr(GSTAT_EXPR *expr) {$/;"	f	file:
check_edges	polygon.c	/^void check_edges(DATA *d, const DPOINT *where) {$/;"	f
check_global_variables	glvars.c	/^void check_global_variables(void) {$/;"	f
check_mem	utils.c	/^void check_mem(char *f, int *l) {$/;"	f
check_only	gstat.c	/^static int check_only = 0;$/;"	v	file:
check_open	predict.c	/^static GRIDMAP *check_open(const char *name, int i) {$/;"	f	file:
check_open_edges	polygon.c	/^static unsigned int check_open_edges(const PLOT_POINT data, const int target_side,$/;"	f	file:
check_status	ext_dbase.c	/^static void check_status(DATA *d) {$/;"	f	file:
check_variography	vario.c	/^void check_variography(const VARIOGRAM **v, int n_vars)$/;"	f
choose_variable	ui.c	/^void choose_variable(int key) {$/;"	f
choose_what	ui.c	/^void choose_what(int key) {$/;"	f
clean_up	glvars.c	/^static void clean_up(void) {$/;"	f	file:
close_curses	ui.c	/^void close_curses(void) {$/;"	f
close_gstat_log_file	gstat.c	/^void close_gstat_log_file(void) {$/;"	f
cm	random.c	/^static double c, cd, cm;$/;"	v	file:
cmd_written	ui.c	/^int wind = 0, cmd_written = 0, use_pipe = 0;$/;"	v
col1	parse.c	/^static int id = -1, id1 = -1, id2 = -1, col1 = -1, col2 = -1,$/;"	v	file:
col2	parse.c	/^static int id = -1, id1 = -1, id2 = -1, col1 = -1, col2 = -1,$/;"	v	file:
collapse	random.c	/^static unsigned int collapse (int anyint, unsigned int size)$/;"	f	file:
colour_table	map2gd.c	/^char colour_table[256] = "", *title = NULL, tmp_str[256] = "";$/;"	v
command	ui.c	/^Command command[MAX_OPTION] = {$/;"	v
command_file_name	glvars.c	/^char *command_file_name;$/;"	v
command_line	glvars.c	/^char *command_line;$/;"	v
compare	report.c	/^int CDECL compare(const double *a, const double *b) $/;"	f
cond_sim	sim.c	/^const double *cond_sim(double *est, int dim, METHOD m, int *is_datum, int orc) {$/;"	f
contains_intercept	lm.c	/^static int contains_intercept(MAT *X) {$/;"	f	file:
convert_C	gls.c	/^static void convert_C(MAT *C, VEC *mu, double (*fn)(double)) {$/;"	f	file:
convert_C0	gls.c	/^static void convert_C0(MAT *C0, VEC *mu, VEC *mu0, double (*fn)(double)) {$/;"	f	file:
convert_MSPE	gls.c	/^static void convert_MSPE(MAT *MSPE, VEC *mu0, double (*fn)(double)) {$/;"	f	file:
convert_help	maputils.c	/^static void convert_help(char *prog) {$/;"	f	file:
convert_null_to_space	utils.c	/^static void convert_null_to_space(char *cp, const char *fname, const FILE *stream) {$/;"	f	file:
coordinates_are_equal	data.c	/^int coordinates_are_equal(const DATA *a, const DATA *b) {$/;"	f
correct_for_anisotropy	fit.c	/^static void correct_for_anisotropy(VARIOGRAM *v) {$/;"	f	file:
correct_orv	sim.c	/^void correct_orv(double *est, int n_vars, int orc) {$/;"	f
correct_strata	data.c	/^static void correct_strata(DATA *d) {$/;"	f	file:
cos_tol_hor	direct.c	/^	cos_tol_hor = -1.0, cos_tol_ver = -1.0, \/* Changed K.M. Fri Feb 27 11:13:47 1998 *\/$/;"	v	file:
cos_tol_ver	direct.c	/^	cos_tol_hor = -1.0, cos_tol_ver = -1.0, \/* Changed K.M. Fri Feb 27 11:13:47 1998 *\/$/;"	v	file:
covariogram	sem.c	/^static SAMPLE_VGM *covariogram(DATA *d, SAMPLE_VGM *ev) {$/;"	f	file:
cp	lex.c	/^static char *cp = NULL;$/;"	v	file:
cpu_is_little_endian	utils.c	/^int cpu_is_little_endian(void) {$/;"	f
create_data_area	glvars.c	/^DATA *create_data_area(void) {$/;"	f
create_lm	lm.c	/^static void create_lm(DATA **data, int nvars) {$/;"	f	file:
cross	xvalid.c	/^static int cross = 0;$/;"	v	file:
cross_covariogram	sem.c	/^static SAMPLE_VGM *cross_covariogram(DATA *a, DATA *b, SAMPLE_VGM *ev) {$/;"	f	file:
cross_valid	xvalid.c	/^void cross_valid(DATA **data) {$/;"	f
cross_variogram	sem.c	/^static SAMPLE_VGM *cross_variogram(DATA *a, DATA *b, SAMPLE_VGM *ev) {$/;"	f	file:
ct_mvaddstr	ui.c	166;"	d	file:
curses_error	ui.c	/^void curses_error(const char *msg, int errno) {$/;"	f
curses_open	ui.c	/^	warning_set = 0, curses_open = 0;$/;"	v	file:
curses_printlog	ui.c	/^void curses_printlog(const char *s) {$/;"	f
curses_warning	ui.c	/^void curses_warning(const char *msg) {$/;"	f
cutoff_width	ui.c	/^void cutoff_width(int key) {$/;"	f
d	parse.c	/^static DATA *d = NULL, **dpp = NULL;$/;"	v	file:
d2s	msim.c	/^	**d2s = NULL;$/;"	v	file:
d_cmp	stat.c	/^int CDECL d_cmp(const double *a, const double *b) {$/;"	f
da_fn_exponential	vario_fn.c	/^double da_fn_exponential(double h, double *r) {$/;"	f
da_fn_gaussian	vario_fn.c	/^double da_fn_gaussian(double h, double *r) {$/;"	f
da_fn_hole	vario_fn.c	/^double da_fn_hole(double h, double *r) {$/;"	f
da_fn_linear	vario_fn.c	/^double da_fn_linear(double h, double *r) {$/;"	f
da_fn_logarithmic	vario_fn.c	/^double da_fn_logarithmic(double h, double *r) {$/;"	f
da_fn_pentaspherical	vario_fn.c	/^double da_fn_pentaspherical(double h, double *r) {$/;"	f
da_fn_periodic	vario_fn.c	/^double da_fn_periodic(double h, double *r) {$/;"	f
da_fn_power	vario_fn.c	/^double da_fn_power(double h, double *r) {$/;"	f
da_fn_spherical	vario_fn.c	/^double da_fn_spherical(double h, double *r) {$/;"	f
da_general	vario.c	/^double da_general(VGM_MODEL *part, double h) {$/;"	f
da_is_zero	vario_fn.c	/^double da_is_zero(double h, double *r) {$/;"	f
data	glvars.c	/^static DATA **data = NULL;$/;"	v	file:
data_add_X	data.c	/^void data_add_X(DATA *d, int col) {$/;"	f
data_area	glvars.c	/^static DATA *data_area = NULL; \/* area that discretises block *\/$/;"	v	file:
data_block_diagonal	data.c	/^double data_block_diagonal(DATA *data) {$/;"	f
data_not_valid	ui.c	/^int data_not_valid(DATA *data) {$/;"	f
data_types	data.c	/^const DATA_TYPE data_types[] = {$/;"	v
datagrid_rebuild	data.c	/^void datagrid_rebuild(DATA *d, int adjust_to_gridcentres) {$/;"	f
db	ext_dbase.c	/^  PQDbase      *db;$/;"	m	struct:__anon2	file:
debug_level	glvars.c	/^int debug_level; \/* debug level *\/$/;"	v
debug_level	mapio.c	/^int debug_level = 1, gl_secure = 0, gl_rowwise = 1;$/;"	v
debug_level	random.c	/^ int debug_level = 0;$/;"	v
debug_result	gls.c	/^static void debug_result(VEC *blup, MAT *MSPE, enum GLS_WHAT pred) {$/;"	f	file:
decide_on_coincide	glvars.c	/^int decide_on_coincide(void) {$/;"	f
default_error	userio.c	/^void default_error(const char *mess, int level) {$/;"	f
default_misval_idrisi	mapio.c	/^static float default_misval_idrisi = 0.0;$/;"	v	file:
default_printlog	userio.c	/^void default_printlog(const char *mess) {$/;"	f
default_progress	userio.c	/^void default_progress(unsigned int current, unsigned int total) {$/;"	f
default_warning	userio.c	/^void default_warning(const char *mess) {$/;"	f
dequeue	pqueue.c	/^Q_ELEMENT_WHAT dequeue(QUEUE *q) {$/;"	f
dir_h	direct.c	/^	dir_v[2] = { 1.0, 0.0 } , dir_h[2] = { 0.0, 1.0 };$/;"	v	file:
dir_v	direct.c	/^	dir_v[2] = { 1.0, 0.0 } , dir_h[2] = { 0.0, 1.0 };$/;"	v	file:
direction	ui.c	/^void direction(int key) {$/;"	f
display_map	ui.c	/^void display_map(int key) {$/;"	f
display_menu	ui.c	/^void display_menu(int option) {$/;"	f
display_msg	ui.c	/^void display_msg(const char *msg) {$/;"	f
dist_cmp	polygon.c	/^static int CDECL dist_cmp(const DPOINT **pa, const DPOINT **pb) {$/;"	f	file:
dist_cmp	select.c	/^int CDECL dist_cmp(const DPOINT **pa, const DPOINT **pb) {$/;"	f
distance_str	plot.c	/^	char *term_name, *term_opt, *gamma_str, *distance_str;$/;"	m	struct:__anon8	file:
divide	sem.c	/^static void divide(SAMPLE_VGM *ev) {$/;"	f	file:
dj_cursorx	ui.c	/^static int dj_cursorx, dj_cursory;$/;"	v	file:
dj_cursory	ui.c	/^static int dj_cursorx, dj_cursory;$/;"	v	file:
dj_textsave	ui.c	/^static char *dj_textsave=NULL;$/;"	v	file:
do_help	sem_main.c	/^static void do_help(void) {$/;"	f	file:
do_one_map2gd	map2gd.c	/^static int do_one_map2gd(char *map, const char *f_name, int legend) {$/;"	f	file:
do_variogram	gstat.c	/^static void do_variogram(int nvars, METHOD m) {$/;"	f	file:
double_index_cmp	utils.c	/^int CDECL double_index_cmp(const Double_index *a, const Double_index *b) {$/;"	f
double_is_mv	data.c	/^static int double_is_mv(DATA *d, double *f) {$/;"	f	file:
dpp	parse.c	/^static DATA *d = NULL, **dpp = NULL;$/;"	v	file:
draw_map	map2fig.c	/^static void draw_map(GRIDMAP *m, int bg) {$/;"	f	file:
draw_map_box	map2gd.c	/^	nc_max = 0, n_table = 0, nclass = 16, draw_map_box = 0, ticks = 0;$/;"	v
draw_one_cell	map2gd.c	/^static void draw_one_cell(gdImagePtr g, int x, int y, $/;"	f	file:
dump_all	glvars.c	/^int dump_all(void) {$/;"	f
dup_csf	mapio.c	/^static GRIDMAP *dup_csf(GRIDMAP * m, GRIDMAP * dup)$/;"	f	file:
dval	parse.c	/^	double dval;$/;"	m	union:YYSTYPE	file:
e_random	random.c	/^int e_random(int argc, char *argv[]) {$/;"	f
ecalloc	utils.c	/^void *ecalloc(size_t nobj, size_t size) {$/;"	f
edcalloc	utils.c	/^void *edcalloc(size_t nobj, size_t size, char *file, int line) {$/;"	f
edf	ui.c	/^static char *edf = "Enter data first";$/;"	v	file:
edfree	utils.c	/^void edfree(void *p, char *file, int line) {$/;"	f
edges	glvars.c	/^static POLYGON **edges = NULL;            \/* per-file edges *\/$/;"	v	file:
edges_names	glvars.c	/^static char **edges_names = NULL;  \/* names of edges files, n_edges long *\/$/;"	v	file:
edmalloc	utils.c	/^void *edmalloc(size_t size, char *file, int line) {$/;"	f
edrealloc	utils.c	/^void *edrealloc(void *p, size_t size, char *file, int line) {$/;"	f
efclose	userio.c	40;"	d	file:
efclose	utils.c	/^int efclose(FILE *stream) {$/;"	f
effective_range	vario.c	/^double effective_range(const VARIOGRAM *v) {$/;"	f
efopen	utils.c	/^FILE *efopen(const char *filename, const char *mode) {$/;"	f
efree	pqueue.c	56;"	d	file:
efree	utils.c	/^void efree(void *p) {$/;"	f
elapsed	utils.c	/^void elapsed(void) {$/;"	f
emalloc	pqueue.c	54;"	d	file:
emalloc	utils.c	/^void *emalloc(size_t size) {$/;"	f
enlarge_queue	pqueue.c	/^static void enlarge_queue(QUEUE *q) {$/;"	f	file:
enqueue	pqueue.c	/^void enqueue(QUEUE *q, Q_ELEMENT_WHAT *el, int n) {$/;"	f
enter_data	ui.c	/^void enter_data(int key) {$/;"	f
entry	ui.c	/^	char *text, **help, *entry;$/;"	m	struct:__anon14	file:
epclose	utils.c	/^int epclose(FILE *stream) {$/;"	f
epopen	utils.c	/^FILE *epopen(const char *filename, const char *mode) {$/;"	f
er_datum	mapio.c	/^static char *er_datum = NULL;$/;"	v	file:
er_projection	mapio.c	/^static char *er_projection = NULL;$/;"	v	file:
erealloc	pqueue.c	55;"	d	file:
erealloc	utils.c	/^void *erealloc(void *p, size_t size) {$/;"	f
eremove	utils.c	/^int eremove(const char *name) {$/;"	f
error_handler	userio.c	/^	void (*error_handler)(const char *mess, int level);$/;"	m	struct:__anon15	file:
error_message	userio.c	/^	*error_message = NULL, $/;"	v	file:
error_messages	userio.c	/^const char *error_messages[MAX_ERRNO+1] = {$/;"	v
error_prefix	userio.c	/^	*error_prefix = NULL, $/;"	v	file:
est	predict.c	/^static double *est = NULL;$/;"	v	file:
est_quant	stat.c	/^double est_quant(double *list, double p, int n) {$/;"	f
est_quantile_div	getest.c	/^static void est_quantile_div(DATA *data, double *est, int div) {$/;"	f	file:
est_skew_kurt	getest.c	/^static void est_skew_kurt(DATA *data, double *est) {$/;"	f	file:
esystem	utils.c	/^int esystem(char *cmd) {$/;"	f
etmpfile	utils.c	/^FILE *etmpfile(void) {$/;"	f
ev2map	sem.c	/^static void ev2map(VARIOGRAM *v) {$/;"	f	file:
exec_action	gstat.c	/^static int exec_action(int argc, char *argv[]) {$/;"	f	file:
exit_predictions	predict.c	/^static void exit_predictions(PRED_AT what) {$/;"	f	file:
expr	parse.c	/^GSTAT_EXPR expr = { NULL, NULL, UNKNOWN, NOLIMIT };$/;"	v
f	utils.c	/^	const FILE *f;$/;"	m	struct:__anon18	file:
field_error	data.c	/^static void field_error(char *fname, int line_nr, int fld, char *text) {$/;"	f	file:
fig_block	fig.c	/^void fig_block(int color, int xmin, int ymin, int xmax, int ymax, int line) {$/;"	f
fig_color	fig.c	/^void fig_color(int color, float *col) {$/;"	f
fig_end	fig.c	/^void fig_end(void) {$/;"	f
fig_legend	fig.c	/^void fig_legend(char *entries[], int n, LEGEND_MODE leg_mode) {$/;"	f
fig_point	fig.c	/^void fig_point(int color, double x, double y, int radius) {$/;"	f
fig_run	fig.c	/^void fig_run(int color, double x0, double y0, double cellsizex, double cellsizey, int rl) {$/;"	f
fig_setup	fig.c	/^void fig_setup(char *fname, double xmin, double ymin, double xmax, double ymax) {$/;"	f
file_exists	utils.c	/^int file_exists(const char *name) {$/;"	f
file_record	utils.c	/^static FILE_RECORD *file_record = NULL;$/;"	v	file:
file_record_size	utils.c	/^static int file_record_size = 0;$/;"	v	file:
file_size	utils.c	/^size_t file_size(const char *fname) {$/;"	f
fill_cutoff_width	sem.c	/^void fill_cutoff_width(DATA *data \/* pointer to DATA structure to derive$/;"	f
fill_entries	ui.c	/^void fill_entries(void) {$/;"	f
fill_est	gls.c	/^static void fill_est(DATA **d, VEC *blup, MAT *MSPE, int n_vars, double *est)$/;"	f	file:
fill_weights	fit.c	/^static int fill_weights(const VARIOGRAM *vp, PERM *p, LM *lm) {$/;"	f	file:
find_class	map2fig.c	/^static int find_class(D_VECTOR *classes, double attr) {$/;"	f	file:
find_classes	map2fig.c	/^D_VECTOR *find_classes(GRIDMAP *m, DATA *d, double min, double max, $/;"	f
find_entry	map2gd.c	/^static int find_entry(float *table, int n_table, float value) {$/;"	f	file:
find_reasonable_hash_interval	map2gd.c	/^static double find_reasonable_hash_interval(double range) {$/;"	f	file:
find_reasonable_hash_start	map2gd.c	/^static double find_reasonable_hash_start(double min, double max, double hash_interval) {$/;"	f	file:
fit_GaussNewton	fit.c	/^static int fit_GaussNewton(VARIOGRAM *vp, PERM *p, LM *lm, int iter,$/;"	f	file:
fit_int2enum	vario.c	/^FIT_TYPE fit_int2enum(int fit) {$/;"	f
fit_method	ui.c	/^void fit_method(int key) {$/;"	f
fit_progress	ui.c	/^void fit_progress(unsigned int step, unsigned int max_step) {$/;"	f
fit_range	parse.c	/^	fit_sill = 0, fit_range = 0, nrangepars = 1,$/;"	v	file:
fit_shift	vario.c	/^FIT_TYPE fit_shift(FIT_TYPE now, int next) {$/;"	f
fit_sill	parse.c	/^	fit_sill = 0, fit_range = 0, nrangepars = 1,$/;"	v	file:
fit_type_str	ui.c	/^char *fit_type_str[] = { $/;"	v
fit_variogram	fit.c	/^int fit_variogram(VARIOGRAM *v) {$/;"	f
fit_vgm	ui.c	/^int fit_vgm(VARIOGRAM *v) {$/;"	f
fix_minmax	data.c	/^static int fix_minmax = 0;$/;"	v	file:
fix_toggle	ui.c	/^void fix_toggle(VARIOGRAM *v, int fix) {$/;"	f
flex_int16_t	lex.c	/^typedef int16_t flex_int16_t;$/;"	t	file:
flex_int16_t	lex.c	/^typedef short int flex_int16_t;$/;"	t	file:
flex_int32_t	lex.c	/^typedef int flex_int32_t;$/;"	t	file:
flex_int32_t	lex.c	/^typedef int32_t flex_int32_t;$/;"	t	file:
flex_int8_t	lex.c	/^typedef int8_t flex_int8_t;$/;"	t	file:
flex_int8_t	lex.c	/^typedef signed char flex_int8_t;$/;"	t	file:
flex_uint16_t	lex.c	/^typedef uint16_t flex_uint16_t;$/;"	t	file:
flex_uint16_t	lex.c	/^typedef unsigned short int flex_uint16_t;$/;"	t	file:
flex_uint32_t	lex.c	/^typedef uint32_t flex_uint32_t;$/;"	t	file:
flex_uint32_t	lex.c	/^typedef unsigned int flex_uint32_t;$/;"	t	file:
flex_uint8_t	lex.c	/^typedef uint8_t flex_uint8_t;$/;"	t	file:
flex_uint8_t	lex.c	/^typedef unsigned char flex_uint8_t; $/;"	t	file:
fn_bessel	vario_fn.c	/^double fn_bessel(double h, double *r) {$/;"	f
fn_circular	vario_fn.c	/^double fn_circular(double h, double *r) {$/;"	f
fn_exclass	vario_fn.c	/^double fn_exclass(double h, double *r) {$/;"	f
fn_exponential	vario_fn.c	/^double fn_exponential(double h, double *r) {$/;"	f
fn_gaussian	vario_fn.c	/^double fn_gaussian(double h, double *r) {$/;"	f
fn_hole	vario_fn.c	/^double fn_hole(double h, double *r) {$/;"	f
fn_intercept	vario_fn.c	/^double fn_intercept(double h, double *r) {$/;"	f
fn_legendre	vario_fn.c	/^double fn_legendre(double h, double *r) {$/;"	f
fn_linear	vario_fn.c	/^double fn_linear(double h, double *r) {$/;"	f
fn_logarithmic	vario_fn.c	/^double fn_logarithmic(double h, double *r) {$/;"	f
fn_matern	vario_fn.c	/^double fn_matern(double h, double *p) {$/;"	f
fn_matern2	vario_fn.c	/^double fn_matern2(double h, double *p) {$/;"	f
fn_nugget	vario_fn.c	/^double fn_nugget(double h, double *r) {$/;"	f
fn_pentaspherical	vario_fn.c	/^double fn_pentaspherical(double h, double *r) {$/;"	f
fn_periodic	vario_fn.c	/^double fn_periodic(double h, double *r) {$/;"	f
fn_power	vario_fn.c	/^double fn_power(double h, double *r) {$/;"	f
fn_spherical	vario_fn.c	/^double fn_spherical(double h, double *r) {$/;"	f
fn_spline	vario_fn.c	/^double fn_spline(double h, double *r) {$/;"	f
fname	polygon.c	/^static const char *fname = NULL;$/;"	v	file:
format	lm.c	/^static char    *format = "%14.9g ";$/;"	v	file:
fprint_cmd	writecmd.c	/^void fprint_cmd(FILE *f) { $/;"	f
fprint_gnuplot_model	plot.c	/^void fprint_gnuplot_model(FILE *f, const VARIOGRAM *vgm, int fit) {$/;"	f
fprint_gnuplot_variogram	plot.c	/^int fprint_gnuplot_variogram(FILE *stream, const VARIOGRAM *v,$/;"	f
fprint_header_vgm	sem.c	/^		void fprint_header_vgm(FILE *f, const DATA *a, const DATA *b,$/;"	f
fprint_jgraph_variogram	plot.c	/^int fprint_jgraph_variogram(FILE *f, const VARIOGRAM *v) {$/;"	f
fprint_sample_vgm	sem.c	/^void fprint_sample_vgm(FILE *f, const SAMPLE_VGM *ev) {$/;"	f
fprint_variogram	vario.c	/^void fprint_variogram(FILE *f, const VARIOGRAM *v, int verbose) {$/;"	f
free_d_vector	data.c	/^void free_d_vector(D_VECTOR *v) {$/;"	f
free_data	data.c	/^void free_data(DATA *d) {$/;"	f
free_data_gridmap	data.c	/^static void free_data_gridmap(DATA_GRIDMAP *t) {$/;"	f	file:
free_glm	gls.c	/^void free_glm(void *v_glm) {$/;"	f
free_lm	lm.c	/^void free_lm(void *v_lm) {$/;"	f
free_queue	pqueue.c	/^void free_queue(QUEUE *q) {$/;"	f
free_simulations	msim.c	/^void free_simulations(void) {$/;"	f
free_strbuf	utils.c	/^void free_strbuf(STRING_BUFFER *b) {$/;"	f
free_variogram	vario.c	/^void free_variogram(VARIOGRAM *v) {$/;"	f
ftoa	utils.c	/^char *ftoa(const char *fmt, float *a) {$/;"	f
function	ui.c	/^	void (*function)(int);$/;"	m	struct:__anon14	file:
gamma_str	plot.c	/^	char *term_name, *term_opt, *gamma_str, *distance_str;$/;"	m	struct:__anon8	file:
gauss	block.c	/^static double gauss[4] = { $/;"	v	file:
gauss_w	block.c	/^double gauss_w[4] = {$/;"	v
generate_grid	ossfim.c	/^static void generate_grid(DATA *d, double samplespacing, int neighbourhood) {$/;"	f	file:
getSSErr	fit.c	/^static double getSSErr(const VARIOGRAM *vp, PERM *p, LM *lm) {$/;"	f	file:
get_X	lm.c	/^MAT *get_X(DATA **d, MAT *X, int nvars) {$/;"	f
get_X0	lm.c	/^MAT *get_X0(DATA **d, MAT *X0, DPOINT *where, int nvars) {$/;"	f
get_area_centre	data.c	/^DATA *get_area_centre(DATA *area, DATA *d) {$/;"	f
get_block_p	glvars.c	/^DPOINT *get_block_p(void) {$/;"	f
get_colX_nr	lm.c	/^static int get_colX_nr(DATA **d, int var, int this_x) {$/;"	f	file:
get_corr_mat	gls.c	/^static MAT *get_corr_mat(MAT *C, MAT *R) {$/;"	f	file:
get_covariance	vario.c	/^double get_covariance(const VARIOGRAM *vp, double dx, double dy, double dz) {$/;"	f
get_covariance_list	s.c	/^SEXP get_covariance_list(SEXP ids, SEXP covariance, SEXP dist_list) {$/;"	f
get_data_area	glvars.c	/^DATA *get_data_area(void) {$/;"	f
get_dataval	glvars.c	/^DATA *get_dataval(void) {$/;"	f
get_default_method	glvars.c	/^METHOD get_default_method(void) {$/;"	f
get_edges	glvars.c	/^POLYGON **get_edges(void) {$/;"	f
get_edges_name	glvars.c	/^const char *get_edges_name(const int i) {$/;"	f
get_est	getest.c	/^void get_est(DATA **data, METHOD method, DPOINT *where, double *est) {$/;"	f
get_free	pqueue.c	/^static Q_ELEMENT *get_free(QUEUE *q) {$/;"	f	file:
get_gstat_data	glvars.c	/^DATA **get_gstat_data(void) {$/;"	f
get_gstat_errno	userio.c	/^enum Gstat_errno get_gstat_errno(void) {$/;"	f
get_gstat_error_message	userio.c	/^const char *get_gstat_error_message(void) {$/;"	f
get_index	nsearch.c	91;"	d	file:
get_index	sem.c	/^static int get_index(double dist, SAMPLE_VGM *ev) {$/;"	f	file:
get_line	utils.c	/^char *get_line(char **s, int *size, FILE *stream) {$/;"	f
get_locations	ui.c	/^void get_locations(int key) {$/;"	f
get_map_location	predict.c	/^static int get_map_location(DPOINT *loc, int random_path,$/;"	f	file:
get_mask0	predict.c	/^const void *get_mask0(void) {$/;"	f
get_maskX	predict.c	/^static double *get_maskX(DATA **data, DPOINT *p,$/;"	f	file:
get_mask_name	glvars.c	/^const char *get_mask_name(int i) {$/;"	f
get_max_sill	vario.c	/^double get_max_sill(int n) {$/;"	f
get_method	glvars.c	/^METHOD get_method(void) {$/;"	f
get_minmax_y	plot.c	/^static void get_minmax_y(const VARIOGRAM *v, double max_x, double *min_y, double *max_y) {$/;"	f	file:
get_mode	glvars.c	/^MODE get_mode(void) {$/;"	f
get_mouse_button	ui.c	/^int get_mouse_button(void) {$/;"	f
get_mouse_y	ui.c	/^int get_mouse_y(void) {$/;"	f
get_msim	msim.c	/^float ***get_msim(void) {$/;"	f
get_mu	gls.c	/^static VEC *get_mu(VEC *mu, const VEC *y, DATA **d, int n_vars) {$/;"	f	file:
get_n_beta_set	glvars.c	/^int get_n_beta_set(void) {$/;"	f
get_n_edges	glvars.c	/^int get_n_edges(void) {$/;"	f
get_n_edges_polys	glvars.c	/^int *get_n_edges_polys(void) {$/;"	f
get_n_masks	glvars.c	/^int get_n_masks(void) {$/;"	f
get_n_outfile	glvars.c	/^int get_n_outfile(void) {$/;"	f
get_n_sim_locs_table	predict.c	/^unsigned int *get_n_sim_locs_table(unsigned int *size) {$/;"	f
get_n_variogram_models	vario.c	/^int get_n_variogram_models(void) {$/;"	f
get_n_vars	glvars.c	/^int get_n_vars(void) {$/;"	f
get_n_vgms	glvars.c	/^int get_n_vgms(void) {$/;"	f
get_nearest_point	nsearch.c	/^static DPOINT *get_nearest_point(QUEUE *q, DPOINT *where, DATA *d) {$/;"	f	file:
get_neighbourhood	ui.c	/^void get_neighbourhood(int key) {$/;"	f
get_next_random_number	random.c	/^double get_next_random_number(void)$/;"	f
get_outfile_name	glvars.c	/^const char **get_outfile_name(void) {$/;"	f
get_outfile_namei	glvars.c	/^const char *get_outfile_namei(int i) {$/;"	f
get_point_location	predict.c	/^static DPOINT *get_point_location(int random_path) {$/;"	f	file:
get_random_cell	predict.c	/^static int get_random_cell(GRIDMAP *m, unsigned int *row, unsigned int *col) {$/;"	f	file:
get_sample	sample.c	/^static PTS_LIST *get_sample(PTS_LIST *idx, int size, int nrows, int ncols) {$/;"	f	file:
get_seed	random.c	/^unsigned long int get_seed(void) {$/;"	f
get_semivariance	vario.c	/^double get_semivariance(const VARIOGRAM *vp, double dx, double dy, double dz) {$/;"	f
get_tm	vario.c	/^static ANIS_TM *get_tm(double anis[5]) {$/;"	f	file:
get_values	fit.c	/^static void get_values(const char *fname, VARIOGRAM *v) {$/;"	f	file:
get_vgm	glvars.c	/^VARIOGRAM *get_vgm(int i) {$/;"	f
get_weights	lm.c	/^static VEC *get_weights(DATA **d, VEC *weights, int nvars) {$/;"	f	file:
get_y	lm.c	/^VEC *get_y(DATA **d, VEC *y, int nvars) {$/;"	f
getopt	getopt.c	/^getopt(nargc, nargv, ostr)$/;"	f
gl_alpha	glvars.c	/^double gl_alpha; \/* alpha, beta, tol_[hor|ver]: anisotropy parameters *\/$/;"	v
gl_beta	glvars.c	/^double gl_beta;$/;"	v
gl_bounds	glvars.c	/^double *gl_bounds; \/* boundaries semivariogram intervals *\/$/;"	v
gl_cn_max	glvars.c	/^double gl_cn_max; \/* check maximum condition number. Default: don't *\/$/;"	v
gl_coincide	glvars.c	/^int gl_coincide; \/* do the variable locations coincide? *\/$/;"	v
gl_cressie	glvars.c	/^int gl_cressie; \/* use cressie's estimator ? *\/$/;"	v
gl_cutoff	glvars.c	/^double gl_cutoff; \/* variogram cutoff *\/$/;"	v
gl_display	glvars.c	/^char *gl_display;$/;"	v
gl_dots	glvars.c	/^int gl_dots; \/* treshold nr for points -> dots, gnuplot *\/$/;"	v
gl_fit	glvars.c	/^int gl_fit; \/* do not fit a variogram *\/$/;"	v
gl_fit_limit	glvars.c	/^double gl_fit_limit; \/* convergence criterion on fit *\/$/;"	v
gl_format	glvars.c	/^char *gl_format;$/;"	v
gl_fraction	glvars.c	/^double gl_fraction; \/* fraction of max dist for cutoff *\/$/;"	v
gl_gauss	glvars.c	/^int gl_gauss; \/* gaussian quadr. block covariances ? *\/$/;"	v
gl_gcv	glvars.c	/^double gl_gcv; \/* generalized covariance constant *\/$/;"	v
gl_gls_residuals	glvars.c	/^int gl_gls_residuals; \/* calc. gls residuals? *\/$/;"	v
gl_gnuplot	glvars.c	/^char *gl_gnuplot;$/;"	v
gl_gnuplot35	glvars.c	/^char *gl_gnuplot35;$/;"	v
gl_gpterm	glvars.c	/^char *gl_gpterm;$/;"	v
gl_idp	glvars.c	/^double gl_idp; \/* default inverse distance power *\/$/;"	v
gl_iter	glvars.c	/^int gl_iter; \/* max. n. iter for mivque estimates *\/$/;"	v
gl_iwidth	glvars.c	/^double gl_iwidth; \/* variogram class width *\/$/;"	v
gl_jgraph	glvars.c	/^int gl_jgraph; \/* do jgraph plot in batch mode ? *\/$/;"	v
gl_lhs	glvars.c	/^int gl_lhs; \/* apply Latin hypercube sampling to Gaussian simulations *\/$/;"	v
gl_longlat	glvars.c	/^int gl_longlat; \/* indicates whether coordinates are longitude\/latitude, or Euclidian *\/$/;"	v
gl_marginal_names	glvars.c	/^char **gl_marginal_names;$/;"	v
gl_marginal_values	glvars.c	/^double *gl_marginal_values;$/;"	v
gl_mv_string	glvars.c	/^char *gl_mv_string;$/;"	v
gl_mv_string	mapio.c	/^char *gl_mv_string = "NA";$/;"	v
gl_mv_string	random.c	/^ char *gl_mv_string = "NA";$/;"	v
gl_n_intervals	glvars.c	/^int gl_n_intervals; \/* n variogram intervals *\/$/;"	v
gl_n_marginals	glvars.c	/^int gl_n_marginals; \/* the n marginal distributions *\/$/;"	v
gl_n_uk	glvars.c	/^int gl_n_uk; \/* min. # of cs points to use ok *\/$/;"	v
gl_nblockdiscr	glvars.c	/^int gl_nblockdiscr; \/* block discrimination in each dimension *\/$/;"	v
gl_nocheck	glvars.c	/^int gl_nocheck; \/* do not check LMC\/IC ? *\/$/;"	v
gl_nsim	glvars.c	/^int gl_nsim; \/* number of simultanious simulations *\/$/;"	v
gl_numbers	glvars.c	/^int gl_numbers; \/* plot numbers on variogram plot? *\/$/;"	v
gl_order	glvars.c	/^int gl_order; \/* do order relation correction *\/$/;"	v
gl_pager	glvars.c	/^char *gl_pager;$/;"	v
gl_plotfile	glvars.c	/^char *gl_plotfile;  \/* gnuplot file name *\/$/;"	v
gl_plotweights	glvars.c	/^int gl_plotweights; \/* plot kriging weights? *\/$/;"	v
gl_quantile	glvars.c	/^double gl_quantile; \/* sample quantile *\/$/;"	v
gl_register_pairs	glvars.c	/^int gl_register_pairs; \/* register sample variogram pairs? *\/$/;"	v
gl_rowwise	glvars.c	/^int gl_rowwise; \/* deal with raster maps row-wise, or as complete blocks? *\/$/;"	v
gl_rowwise	mapio.c	/^int debug_level = 1, gl_secure = 0, gl_rowwise = 1;$/;"	v
gl_rp	glvars.c	/^int gl_rp; \/* follow random path for gs\/is? *\/$/;"	v
gl_secure	glvars.c	/^int gl_secure; \/* disallow system() and popen()? *\/$/;"	v
gl_secure	mapio.c	/^int debug_level = 1, gl_secure = 0, gl_rowwise = 1;$/;"	v
gl_secure	random.c	/^ int gl_secure = 0;$/;"	v
gl_seed	glvars.c	/^int gl_seed; \/* seed is set? *\/$/;"	v
gl_sim_beta	glvars.c	/^int gl_sim_beta; \/* simulation mode for beta: 0 multiv GLS, 1 univ GLS, 2 OLS *\/$/;"	v
gl_sparse	glvars.c	/^int gl_sparse; \/* use sparse covariance matrices? *\/$/;"	v
gl_spiral	glvars.c	/^int gl_spiral; \/* do spiral search if possible? *\/$/;"	v
gl_split	glvars.c	/^int gl_split; \/* see nsearch.c: was Q_SPLIT_AT *\/$/;"	v
gl_sym_ev	glvars.c	/^int gl_sym_ev; \/* default symmetric ps.cr.v.\/cr.cv. ? *\/$/;"	v
gl_tol_hor	glvars.c	/^double gl_tol_hor;$/;"	v
gl_tol_ver	glvars.c	/^double gl_tol_ver;$/;"	v
gl_xvalid	glvars.c	/^int gl_xvalid; \/* do cross validation on first variable *\/$/;"	v
gl_zero	glvars.c	/^double gl_zero; \/* zero tolerance; 2-squared *\/$/;"	v
gl_zero	mapio.c	/^double gl_zero = DEF_zero;$/;"	v
gl_zero_est	glvars.c	/^int gl_zero_est; \/* est. variogram at h 0 seperately? *\/$/;"	v
gl_zmap	glvars.c	/^double gl_zmap; \/* height of the map *\/$/;"	v
gls	gls.c	/^void gls(DATA **d \/* pointer to DATA array *\/,$/;"	f
gnu_fit	fit.c	/^static void gnu_fit(VARIOGRAM *v) {$/;"	f	file:
gnu_stream	ui.c	/^static FILE *gnu_stream = NULL;$/;"	v	file:
gnuplot_name	ui.c	/^char *header = NULL, *msg = NULL, *gnuplot_name = NULL;$/;"	v
gnuplot_terms	plot.c	/^GNUPLOT_TERM gnuplot_terms[] = {$/;"	v
grass	utils.c	/^int grass(void) {$/;"	f
grid_push_point	data.c	/^static void grid_push_point(DATA *d, DPOINT *p, int adjust_to_gridcentres) {$/;"	f	file:
gsetup_gridmap	data.c	/^DATA_GRIDMAP *gsetup_gridmap(double x_ul, double y_ul, double cellsizex, $/;"	f
gstat_S_fillgrid	s.c	/^static DATA_GRIDMAP *gstat_S_fillgrid(SEXP gridparams) {$/;"	f	file:
gstat_clo_error	userio.c	/^void gstat_clo_error(char *f, int l, enum Gstat_errno err, int a) {$/;"	f
gstat_debug_level	s.c	/^SEXP gstat_debug_level(SEXP level) {$/;"	f
gstat_errno	userio.c	/^static enum Gstat_errno gstat_errno;$/;"	v	typeref:enum:Gstat_errno	file:
gstat_error	userio.c	/^void gstat_error(char *fname, int line,$/;"	f
gstat_exit	s.c	/^SEXP gstat_exit(SEXP x) {$/;"	f
gstat_fit_variogram	s.c	/^SEXP gstat_fit_variogram(SEXP fit, SEXP fit_sill, SEXP fit_range) {$/;"	f
gstat_gcdist	gcdist.c	/^double gstat_gcdist(double lon1, double lon2, double lat1, double lat2) {$/;"	f
gstat_get_variogram_models	s.c	/^SEXP gstat_get_variogram_models(SEXP dolong) {$/;"	f
gstat_handler	userio.c	/^} gstat_handler = { NULL, NULL, NULL, NULL };$/;"	v	typeref:struct:__anon15	file:
gstat_init	s.c	/^SEXP gstat_init(SEXP s_debug_level) {$/;"	f
gstat_load_command	s.c	/^SEXP gstat_load_command(SEXP commands) {$/;"	f
gstat_load_ev	s.c	/^SEXP gstat_load_ev(SEXP np, SEXP dist, SEXP gamma) {$/;"	f
gstat_load_variogram	s.c	/^SEXP gstat_load_variogram(SEXP s_ids, SEXP s_model, SEXP s_sills, SEXP s_ranges, $/;"	f
gstat_new_data	s.c	/^SEXP gstat_new_data(SEXP sy, SEXP slocs, SEXP sX, SEXP has_intercept, $/;"	f
gstat_new_dummy_data	s.c	/^SEXP gstat_new_dummy_data(SEXP loc_dim, SEXP has_intercept, SEXP beta, $/;"	f
gstat_predict	s.c	/^SEXP gstat_predict(SEXP sn, SEXP slocs, SEXP sX, SEXP block_cols, SEXP block, $/;"	f
gstat_set_block	s.c	/^static void gstat_set_block(long i, SEXP block, SEXP block_cols, DPOINT *current) {$/;"	f	file:
gstat_start	utils.c	/^void gstat_start(void) {$/;"	f
gstat_variogram	s.c	/^SEXP gstat_variogram(SEXP s_ids, SEXP cutoff, SEXP width, SEXP direction, $/;"	f
gstat_variogram_values	s.c	/^SEXP gstat_variogram_values(SEXP ids, SEXP pars, SEXP covariance, SEXP dist_values) {$/;"	f
gstat_yy_create_buffer	lex.c	/^    YY_BUFFER_STATE gstat_yy_create_buffer  (FILE * file, int  size )$/;"	f
gstat_yy_delete_buffer	lex.c	/^    void gstat_yy_delete_buffer (YY_BUFFER_STATE  b )$/;"	f
gstat_yy_flex_debug	lex.c	/^int gstat_yy_flex_debug = 0;$/;"	v
gstat_yy_flush_buffer	lex.c	/^    void gstat_yy_flush_buffer (YY_BUFFER_STATE  b )$/;"	f
gstat_yy_init_buffer	lex.c	/^    static void gstat_yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )$/;"	f	file:
gstat_yy_load_buffer_state	lex.c	/^static void gstat_yy_load_buffer_state  (void)$/;"	f	file:
gstat_yy_scan_buffer	lex.c	/^YY_BUFFER_STATE gstat_yy_scan_buffer  (char * base, yy_size_t  size )$/;"	f
gstat_yy_scan_bytes	lex.c	/^YY_BUFFER_STATE gstat_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )$/;"	f
gstat_yy_scan_string	lex.c	/^YY_BUFFER_STATE gstat_yy_scan_string (yyconst char * yystr )$/;"	f
gstat_yy_switch_to_buffer	lex.c	/^    void gstat_yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )$/;"	f
gstat_yyalloc	lex.c	/^void *gstat_yyalloc (yy_size_t  size )$/;"	f
gstat_yyensure_buffer_stack	lex.c	/^static void gstat_yyensure_buffer_stack (void)$/;"	f	file:
gstat_yyerror	parse.c	193;"	d	file:
gstat_yyfree	lex.c	/^void gstat_yyfree (void * ptr )$/;"	f
gstat_yyget_debug	lex.c	/^int gstat_yyget_debug  (void)$/;"	f
gstat_yyget_in	lex.c	/^FILE *gstat_yyget_in  (void)$/;"	f
gstat_yyget_leng	lex.c	/^int gstat_yyget_leng  (void)$/;"	f
gstat_yyget_lineno	lex.c	/^int gstat_yyget_lineno  (void)$/;"	f
gstat_yyget_out	lex.c	/^FILE *gstat_yyget_out  (void)$/;"	f
gstat_yyget_text	lex.c	/^char *gstat_yyget_text  (void)$/;"	f
gstat_yyin	lex.c	/^FILE *gstat_yyin = (FILE *) 0, *gstat_yyout = (FILE *) 0;$/;"	v
gstat_yyleng	lex.c	/^int gstat_yyleng;$/;"	v
gstat_yylex_destroy	lex.c	/^int gstat_yylex_destroy  (void)$/;"	f
gstat_yylineno	lex.c	/^int gstat_yylineno = 1;$/;"	v
gstat_yyout	lex.c	/^FILE *gstat_yyin = (FILE *) 0, *gstat_yyout = (FILE *) 0;$/;"	v
gstat_yypop_buffer_state	lex.c	/^void gstat_yypop_buffer_state (void)$/;"	f
gstat_yypush_buffer_state	lex.c	/^void gstat_yypush_buffer_state (YY_BUFFER_STATE new_buffer )$/;"	f
gstat_yyrealloc	lex.c	/^void *gstat_yyrealloc  (void * ptr, yy_size_t  size )$/;"	f
gstat_yyrestart	lex.c	/^    void gstat_yyrestart  (FILE * input_file )$/;"	f
gstat_yyset_debug	lex.c	/^void gstat_yyset_debug (int  bdebug )$/;"	f
gstat_yyset_in	lex.c	/^void gstat_yyset_in (FILE *  in_str )$/;"	f
gstat_yyset_lineno	lex.c	/^void gstat_yyset_lineno (int  line_number )$/;"	f
gstat_yyset_out	lex.c	/^void gstat_yyset_out (FILE *  out_str )$/;"	f
gstat_yytext	lex.c	/^char *gstat_yytext;$/;"	v
gstat_yywrap	lex.c	/^int gstat_yywrap(void) {$/;"	f
gstat_yywrap	lex.c	573;"	d	file:
header	ui.c	/^char *header = NULL, *msg = NULL, *gnuplot_name = NULL;$/;"	v
help	ui.c	/^	char *text, **help, *entry;$/;"	m	struct:__anon14	file:
help_menu	ui.c	/^void help_menu(int option) {$/;"	f
id	parse.c	/^static int id = -1, id1 = -1, id2 = -1, col1 = -1, col2 = -1,$/;"	v	file:
id1	parse.c	/^static int id = -1, id1 = -1, id2 = -1, col1 = -1, col2 = -1,$/;"	v	file:
id2	parse.c	/^static int id = -1, id1 = -1, id2 = -1, col1 = -1, col2 = -1,$/;"	v	file:
ids	glvars.c	/^static char **outfile_names = NULL, **ids = NULL, **mask_names = NULL;$/;"	v	file:
in_bbox	nsearch.c	/^static int in_bbox(const DPOINT *where, BBOX bbox) {$/;"	f	file:
init	random.c	/^static int init = 0;$/;"	v	file:
init_data	ext_dbase.c	/^static void init_data(DATA *d) {$/;"	f	file:
init_data_minmax	data.c	/^void init_data_minmax(void) {$/;"	f
init_dpoint	data.c	/^static void init_dpoint(DATA *d, DPOINT *current) {$/;"	f	file:
init_dpoint	ext_dbase.c	/^static DPOINT* init_dpoint($/;"	f	file:
init_ev	vario.c	/^SAMPLE_VGM *init_ev(void) {$/;"	f
init_global_variables	glvars.c	/^int init_global_variables(void) {$/;"	f
init_gstat_data	glvars.c	/^static void init_gstat_data(int n) {$/;"	f	file:
init_lm	lm.c	/^LM *init_lm(LM *lm) {$/;"	f
init_one_data	data.c	/^DATA *init_one_data(DATA *data) {$/;"	f
init_predictions	predict.c	/^static void init_predictions(PRED_AT w) {$/;"	f	file:
init_qnode	nsearch.c	/^static void init_qnode(QTREE_NODE **p_node, int isleaf, BBOX bb) {$/;"	f	file:
init_qtree	nsearch.c	/^static void init_qtree(DATA *d) {$/;"	f	file:
init_queue	pqueue.c	/^QUEUE *init_queue(QUEUE *q, int (CDECL *cmp)(const Q_ELEMENT_WHAT *a, $/;"	f
init_random	random.c	/^static void init_random(void) {$/;"	f	file:
init_simulations	msim.c	/^void init_simulations(DATA **d) {$/;"	f
init_userio	userio.c	/^void init_userio(int use_stdio) {$/;"	f
init_variogram	vario.c	/^VARIOGRAM *init_variogram(VARIOGRAM *v) {$/;"	f
init_variogram_part	vario.c	/^static void init_variogram_part(VGM_MODEL *p) {$/;"	f	file:
input	lex.c	593;"	d	file:
input	lex.c	601;"	d	file:
int2pal	palet.c	/^PALETTE int2pal(int ipal) {$/;"	f
intercept_only	data.c	/^int intercept_only(const DATA *d) {$/;"	f
interlace	map2gd.c	/^int px = 0, interlace = 0, transparent = 1,$/;"	v
interpolate_pal	palet.c	/^static void interpolate_pal(double pos, PAL *pal, float colors[3]) {$/;"	f	file:
interval	map2gd.c	/^float min, max, interval, *table; $/;"	v
inverse_dist	getest.c	/^static double inverse_dist(DATA *data, DPOINT *where, double idPow) {$/;"	f	file:
is_block_expr	parse.c	/^static int is_block_expr(GSTAT_EXPR *expr, const char *s) {$/;"	f	file:
is_data_expr	parse.c	/^static int is_data_expr(DATA *d, GSTAT_EXPR *expr, const char *fld) {$/;"	f	file:
is_directional	sem.c	/^int is_directional(VARIOGRAM *v) {$/;"	f
is_leaf	nsearch.c	89;"	d	file:
is_left_key	ui.c	165;"	d	file:
is_mv_double	utils.c	/^int is_mv_double(const double *d) {$/;"	f
is_mv_float	utils.c	/^int is_mv_float(const float *f) {$/;"	f
is_one_integer	data.c	/^static int is_one_integer(char *line, int *n) {$/;"	f	file:
is_openf	userio.c	50;"	d	file:
is_posdef	vario.c	/^static int is_posdef(MAT *A) {$/;"	f	file:
is_qtree_search	nsearch.c	90;"	d	file:
is_set_expr	parse.c	/^static int is_set_expr(GSTAT_EXPR *expr, const char *name) {$/;"	f	file:
is_simulation	glvars.c	/^int is_simulation(METHOD m) {$/;"	f
is_singular	lm.c	/^int is_singular(MAT *X, double cond_max) {$/;"	f
is_singular_silent	lm.c	/^static int is_singular_silent(MAT *X, double cond_max, double *ce) {$/;"	f	file:
is_valid_cs	vario.c	/^static int is_valid_cs(const VARIOGRAM *aa, const VARIOGRAM *bb,$/;"	f	file:
is_valid_strata_map	predict.c	/^int is_valid_strata_map(const char *name, int n_vars) {$/;"	f
ival	parse.c	/^	int ival;$/;"	m	union:YYSTYPE	file:
key2plot	ui.c	/^PLOT_TYPE key2plot(int key) {$/;"	f
lastnl	lex.c	/^static const char *yy_Source = NULL, *lastnl = NULL;$/;"	v	file:
lex_error	lex.c	/^void lex_error(void) {$/;"	f
lhs	msim.c	/^void lhs(DATA **d, int n_vars, int stratify) {$/;"	f
lhs_one	msim.c	/^static void lhs_one(Double_index *list, unsigned int dim, $/;"	f	file:
limit	parse.c	/^	} limit;$/;"	m	struct:__anon5	typeref:enum:__anon5::__anon7	file:
line_buf	mapio.c	/^static char *line_buf = NULL;$/;"	v	file:
line_of_sight	polygon.c	/^unsigned char line_of_sight(const PLOT_POINT data, const PLOT_POINT target,$/;"	f
line_size	mapio.c	/^static int line_size = 0;$/;"	v	file:
load_ev	sem.c	/^static SAMPLE_VGM *load_ev(SAMPLE_VGM *ev, const char *fname) {$/;"	f	file:
logfile	userio.c	/^static FILE *logfile = NULL;$/;"	v	file:
logfile_name	glvars.c	/^char *logfile_name;$/;"	v
logprint_cmd	writecmd.c	/^void logprint_cmd() { $/;"	f
logprint_data_header	data.c	/^static void logprint_data_header(const DATA *d) {$/;"	f	file:
logprint_lm	lm.c	/^void logprint_lm(DATA *d, LM *lm) {$/;"	f
logprint_point	data.c	/^void logprint_point(const DPOINT *p, const DATA *d) {$/;"	f
logprint_qtree	nsearch.c	/^static void logprint_qtree(QTREE_NODE *node, int depth) {$/;"	f	file:
logprint_queue	nsearch.c	/^void logprint_queue(QUEUE *queue) {$/;"	f
logprint_variogram	vario.c	/^void logprint_variogram(const VARIOGRAM *v, int verbose) {$/;"	f
lt	plot.c	/^	int pt, lt;$/;"	m	struct:__anon8	file:
m_logoutput	lm.c	/^void m_logoutput(MAT * a)$/;"	f
main	gstat.c	/^int main(int argc, char *argv[]) {$/;"	f
main	mapio.c	/^int main(int argc, char *argv[])$/;"	f
main	pqueue.c	/^int main(int argc, char *argv[]) {$/;"	f
main_sem	sem_main.c	/^int main_sem(int argc, char *argv[]) $/;"	f
make_gls	gls.c	/^double *make_gls(DATA *d, int calc_residuals) {$/;"	f
make_gls_mv	gls.c	/^double *make_gls_mv(DATA **d, int n_vars) {$/;"	f
make_ols	lm.c	/^double *make_ols(DATA *d) {$/;"	f
make_residuals_lm	lm.c	/^void make_residuals_lm(DATA *d) {$/;"	f
map2fig	map2fig.c	/^int map2fig(int argc, char *argv[]) {$/;"	f
map2gd	map2gd.c	/^int map2gd(int argc, char *argv[]) {$/;"	f
map2gd	map2gd.c	104;"	d	file:
map_cell_is_mv	mapio.c	/^int map_cell_is_mv(GRIDMAP * m \/* pointer to map *\/ ,$/;"	f
map_convert	maputils.c	/^int map_convert(int argc, char *argv[]) {$/;"	f
map_cover	maputils.c	/^int map_cover(int argc, char *argv[]) {$/;"	f
map_cut	maputils.c	/^int map_cut(int argc, char *argv[]) {$/;"	f
map_diff	maputils.c	/^int map_diff(int argc, char *argv[]) {$/;"	f
map_dup	mapio.c	/^GRIDMAP *map_dup(const char *fname, GRIDMAP *m)$/;"	f
map_equal	mapio.c	/^int map_equal(GRIDMAP * a, GRIDMAP * b)$/;"	f
map_free	mapio.c	/^void map_free(GRIDMAP * m \/* pointer to GRIDMAP structure *\/ )$/;"	f
map_get_cell	mapio.c	/^float map_get_cell(GRIDMAP * m \/* pointer to GRIDMAP *\/ ,$/;"	f
map_lnh	maputils.c	/^int map_lnh(int argc, char *argv[]) {$/;"	f
map_name_nr	mapio.c	/^void map_name_nr(GRIDMAP *mask, const char *base, char *name, int nr, int max) {$/;"	f
map_nominal	maputils.c	/^int map_nominal(int argc, char *argv[]) {$/;"	f
map_put_cell	mapio.c	/^int map_put_cell(GRIDMAP * m,	\/* pointer to GRIDMAP structure *\/$/;"	f
map_q	maputils.c	/^int map_q(int argc, char *argv[]) {$/;"	f
map_read	mapio.c	/^GRIDMAP *map_read(GRIDMAP * m)$/;"	f
map_rowcol2xy	mapio.c	/^int map_rowcol2xy(GRIDMAP * m,	\/* pointer to gridmap *\/$/;"	f
map_set_row	mapio.c	/^static void map_set_row(GRIDMAP *m, unsigned int new_row)$/;"	f	file:
map_sign	predict.c	/^void map_sign(GRIDMAP *m, const char *what) {$/;"	f
map_switch_type	mapio.c	/^GRIDMAP *map_switch_type(GRIDMAP *in, MAPTYPE type) {$/;"	f
map_xy2rowcol	mapio.c	/^int map_xy2rowcol(GRIDMAP * m \/* pointer to map *\/ ,$/;"	f
mask_names	glvars.c	/^static char **outfile_names = NULL, **ids = NULL, **mask_names = NULL;$/;"	v	file:
mask_topology	predict.c	/^static DATA_GRIDMAP *mask_topology = NULL;$/;"	v	file:
masks	predict.c	/^static GRIDMAP **masks = NULL, **outmap = NULL;$/;"	v	file:
max	data.c	/^static DPOINT min, max;$/;"	v	file:
max	map2gd.c	/^float min, max, interval, *table; $/;"	v
max_block_dimension	glvars.c	/^double max_block_dimension(int reset) {$/;"	f
max_set	map2gd.c	/^	min_set = 0, max_set = 0, table_read = 0, nc = 0, nice_legend = 0,$/;"	v
max_size	sample.c	/^	int max_size, size;$/;"	m	struct:__anon12	file:
message	userio.c	/^void message(char *fmt, ...) {$/;"	f
method	glvars.c	/^static METHOD method = NSP;$/;"	v	file:
method_string	glvars.c	/^const char *method_string(METHOD i) {$/;"	f
methods	glvars.c	/^const METHODS methods[] = { \/* methods and codes *\/$/;"	v
min	data.c	/^static DPOINT min, max;$/;"	v	file:
min	map2gd.c	/^float min, max, interval, *table; $/;"	v
min_set	map2gd.c	/^	min_set = 0, max_set = 0, table_read = 0, nc = 0, nice_legend = 0,$/;"	v
mk_var_names	data.c	/^static void mk_var_names(DATA *d) {$/;"	f	file:
mknan	mapio.c	1824;"	d	file:
mknan	mapio.c	1829;"	d	file:
mknan	mapio.c	1834;"	d	file:
mode	glvars.c	/^static MODE mode = MODE_NSP; \/* MODE_NSP, SIMPLE, STRATIFY or MULTIVARIABLE *\/$/;"	v	file:
mode	utils.c	/^	char *name, *mode;$/;"	m	struct:__anon18	file:
model_shift	vario.c	/^VGM_MODEL_TYPE model_shift(VGM_MODEL_TYPE now, int next) {$/;"	f
more_file	ui.c	/^void more_file(const char *name) {$/;"	f
msg	ui.c	/^char *header = NULL, *msg = NULL, *gnuplot_name = NULL;$/;"	v
msim	msim.c	/^	***msim = NULL, $/;"	v	file:
msim_base	msim.c	/^	**msim_base = NULL; \/* base structure for blocked allocation *\/$/;"	v	file:
mu	gls.c	/^		*mu,       \/* mu vector, E(y) *\/$/;"	m	struct:__anon3	file:
mu0	gls.c	/^		*mu0,      \/* mu at loc x0 *\/$/;"	m	struct:__anon3	file:
my_dtoa	utils.c	/^char *my_dtoa(const char *fmt, double *a) {$/;"	f
my_gsl_normal	random.c	/^double my_gsl_normal(void){$/;"	f
my_gsl_uniform	random.c	/^double my_gsl_uniform(void){$/;"	f
my_normal	random.c	/^double my_normal(void) {$/;"	f
my_rng	random.c	/^} my_rng = { NULL, NULL };$/;"	v	typeref:struct:__anon10	file:
n	palet.c	/^	int n;$/;"	m	struct:__anon4	file:
n_done	predict.c	/^static unsigned int n_done;$/;"	v	file:
n_edges	glvars.c	/^static int n_edges = 0; \/*really n of edges files *\/$/;"	v	file:
n_edges_polys	glvars.c	/^static int *n_edges_polys = NULL;  \/* number of edges in every edge file *\/$/;"	v	file:
n_last	glvars.c	/^static int n_last = 0, n_v_last = 0, n_o_last = 0;$/;"	v	file:
n_mallocs	utils.c	/^unsigned int n_mallocs = 0;$/;"	v
n_masks	glvars.c	/^static int n_vars = 0, n_masks = 0;$/;"	v	file:
n_o_last	glvars.c	/^static int n_last = 0, n_v_last = 0, n_o_last = 0;$/;"	v	file:
n_orvc	sim.c	/^static unsigned int n_orvc = 0, n_total = 0;$/;"	v	file:
n_pred_locs	predict.c	/^unsigned int n_pred_locs = 0;$/;"	v
n_sim_locs	msim.c	/^	*n_sim_locs = NULL, \/* n simulation locations per data variable *\/$/;"	v	file:
n_table	map2gd.c	/^	nc_max = 0, n_table = 0, nclass = 16, draw_map_box = 0, ticks = 0;$/;"	v
n_total	sim.c	/^static unsigned int n_orvc = 0, n_total = 0;$/;"	v	file:
n_v_last	glvars.c	/^static int n_last = 0, n_v_last = 0, n_o_last = 0;$/;"	v	file:
n_variograms_set	glvars.c	/^int n_variograms_set(void) {$/;"	f
n_vars	glvars.c	/^static int n_vars = 0, n_masks = 0;$/;"	v	file:
name	parse.c	/^	const char *name;$/;"	m	struct:__anon5	file:
name	utils.c	/^	char *name, *mode;$/;"	m	struct:__anon18	file:
name_identifier	glvars.c	/^const char *name_identifier(int i) {$/;"	f
nc	map2gd.c	/^	min_set = 0, max_set = 0, table_read = 0, nc = 0, nice_legend = 0,$/;"	v
nc_max	map2gd.c	/^	nc_max = 0, n_table = 0, nclass = 16, draw_map_box = 0, ticks = 0;$/;"	v
nclass	map2gd.c	/^	nc_max = 0, n_table = 0, nclass = 16, draw_map_box = 0, ticks = 0;$/;"	v
nesting_level	fig.c	/^static int nesting_level = 0;$/;"	v	file:
new_glm	gls.c	/^static GLM *new_glm(void) {$/;"	f	file:
new_map	mapio.c	/^GRIDMAP *new_map(MAP_READ_STATUS status)$/;"	f
new_source	lex.c	/^	new_source = 0;$/;"	v	file:
next_location	predict.c	/^static DPOINT *next_location(DPOINT *loc, PRED_AT what, int random_path,$/;"	f	file:
ni	random.c	/^static unsigned int ni;$/;"	v	file:
nice_legend	map2gd.c	/^	min_set = 0, max_set = 0, table_read = 0, nc = 0, nice_legend = 0,$/;"	v
nj	random.c	/^static unsigned int nj;$/;"	v	file:
no_progress	userio.c	/^void no_progress(unsigned int current, unsigned int total) {$/;"	f
node_cmp	nsearch.c	/^static int CDECL node_cmp(const QUEUE_NODE *a, const QUEUE_NODE *b) {$/;"	f	file:
nr	utils.c	/^	int nr, remove_at_exit;$/;"	m	struct:__anon18	file:
nrangepars	parse.c	/^	fit_sill = 0, fit_range = 0, nrangepars = 1,$/;"	v	file:
o_filename	glvars.c	/^char *o_filename;$/;"	v
octant_select	select.c	/^static int octant_select(DATA *d, DPOINT *where) {$/;"	f	file:
offset	ext_dbase.c	/^  double        offset[3];$/;"	m	struct:__anon2	file:
offset	ext_dbase.c	/^static double* offset(DATA *d) {$/;"	f	file:
ofn	parse.c	/^static char **ofn = NULL, *boundary_file = NULL;$/;"	v	file:
old_progress_handler	userio.c	/^static void (*old_progress_handler)(unsigned int this, unsigned int total) $/;"	v	file:
one_map2gd	map2gd.c	/^int one_map2gd(GRIDMAP *m, const char *f_name, TICKS *xt, TICKS *yt, $/;"	f
open_curses	ui.c	/^void open_curses(void) {$/;"	f
optarg	getopt.c	/^char	*optarg;		\/* argument associated with option *\/$/;"	v
opterr	getopt.c	/^int	opterr = 1,		\/* if error message should be printed *\/$/;"	v
optind	getopt.c	/^	optind = 1,		\/* index into parent argv vector *\/$/;"	v
optopt	getopt.c	/^	optopt; 		\/* character checked for validity *\/$/;"	v
ossfim	ossfim.c	/^int ossfim(int argc, char *argv[]) {$/;"	f
ossfim2map	ossfim.c	/^void ossfim2map(double **table, const char *name, double s, double S,$/;"	f
out	fig.c	/^static FILE *out = NULL;$/;"	v	file:
outfile_names	glvars.c	/^static char **outfile_names = NULL, **ids = NULL, **mask_names = NULL;$/;"	v	file:
outmap	predict.c	/^static GRIDMAP **masks = NULL, **outmap = NULL;$/;"	v	file:
output	lex.c	599;"	d	file:
output	lex.c	603;"	d	file:
output_line	report.c	/^static void output_line(FILE *out_file, DATA *data, DPOINT *where, $/;"	f	file:
p	plot.c	/^	PLOT_TYPE p;$/;"	m	struct:__anon8	file:
p_normal	random.c	/^double p_normal(double z) {$/;"	f
p_triangular	random.c	/^double p_triangular(double z) {$/;"	f
p_uniform	random.c	/^double p_uniform(double z) {$/;"	f
pal	map2gd.c	/^PALETTE pal = GYR0;$/;"	v
palet	palet.c	/^int palet(int argc, char *argv[]) {$/;"	f
parse_cmd	parse.c	/^int parse_cmd(const char *cmd, const char *fname) {$/;"	f
parse_file	parse.c	/^int parse_file(const char *fname) {$/;"	f
parse_gstatrc	parse.c	/^void parse_gstatrc(void) {$/;"	f
parse_options	gstat.c	/^static void parse_options(int argc, char *argv[]) {$/;"	f	file:
parse_variogram	parse.c	/^static VARIOGRAM *parse_variogram = NULL;$/;"	v	file:
pb_norm_1D	nsearch.c	/^double pb_norm_1D(const DPOINT *where, BBOX bbox) {$/;"	f
pb_norm_2D	nsearch.c	/^double pb_norm_2D(const DPOINT *where, BBOX bbox) {$/;"	f
pb_norm_3D	nsearch.c	/^double pb_norm_3D(const DPOINT *where, BBOX bbox) {$/;"	f
pb_norm_gc2	data.c	/^static double pb_norm_gc2(const DPOINT *where, BBOX bbox) {$/;"	f	file:
plot_weights	gls.c	/^static void plot_weights(DATA **d, int nvars, DPOINT *where, MAT *weights) {$/;"	f	file:
plotfile	glvars.c	/^FILE *plotfile;$/;"	v
point_in_polygon	polygon.c	/^int point_in_polygon(PLOT_POINT point, POLYGON *pl)$/;"	f
point_norm_1D	data.c	/^static double point_norm_1D(const DPOINT *p) {$/;"	f	file:
point_norm_2D	data.c	/^static double point_norm_2D(const DPOINT *p) {$/;"	f	file:
point_norm_3D	data.c	/^static double point_norm_3D(const DPOINT *p) {$/;"	f	file:
point_norm_gc	data.c	/^static double point_norm_gc(const DPOINT *p) {$/;"	f	file:
polynomial	data.c	/^const POLY_NM polynomial[N_POLY] =$/;"	v
pop_gstat_progress_handler	userio.c	/^void pop_gstat_progress_handler(void) {$/;"	f
pop_point	data.c	/^void pop_point(DATA *d, int list_nr)$/;"	f
pp_norm_1D	data.c	/^static double pp_norm_1D(const DPOINT *a, const DPOINT *b) {$/;"	f	file:
pp_norm_2D	data.c	/^static double pp_norm_2D(const DPOINT *a, const DPOINT *b) {$/;"	f	file:
pp_norm_3D	data.c	/^static double pp_norm_3D(const DPOINT *a, const DPOINT *b) {$/;"	f	file:
pp_norm_gc	data.c	/^double pp_norm_gc(const DPOINT *a, const DPOINT *b) {$/;"	f
pp_norm_gc2	data.c	/^static double pp_norm_gc2(const DPOINT *a, const DPOINT *b) {$/;"	f	file:
pqdbase	ext_dbase.c	/^static PQDbase* pqdbase(DATA *d) {$/;"	f	file:
pr_type_str	ui.c	/^const char *pr_type_str[] = {$/;"	v
pr_warning	userio.c	/^void pr_warning(char *fmt, ...) {$/;"	f
pred_lm	lm.c	/^void pred_lm(DATA **data, int n_vars, DPOINT *where, double *est) {$/;"	f
predict_all	predict.c	/^void predict_all(DATA **data) {$/;"	f
predict_lm	lm.c	/^static void predict_lm(LM *lm, MAT *X0, double *est) {$/;"	f	file:
print_data	data.c	/^void print_data(const DATA *d, int list) {$/;"	f
print_data_line	data.c	/^char *print_data_line(const DATA *d, char **to) {$/;"	f
print_file_record	utils.c	/^void print_file_record(void) {$/;"	f
print_n	utils.c	/^void print_n(void) {$/;"	f
print_orvc	sim.c	/^void print_orvc(void) {$/;"	f
print_poly_log	polygon.c	/^static void print_poly_log(POLYGON *edge) {$/;"	f	file:
print_progress	userio.c	/^void print_progress(unsigned int current, unsigned int total) {$/;"	f
print_queue	pqueue.c	/^static void print_queue(QUEUE *q) {$/;"	f	file:
print_selection	select.c	/^static void print_selection(DATA *d, DPOINT *where) {$/;"	f	file:
print_sim	msim.c	/^void print_sim(void) {$/;"	f
print_start_up	random.c	/^static void print_start_up(void) {$/;"	f	file:
print_to_logfile_if_open	userio.c	/^void print_to_logfile_if_open(const char *mess) {$/;"	f
printlog	random.c	68;"	d	file:
printlog	userio.c	/^void printlog(const char *fmt, ...) {$/;"	f
printlog_handler	userio.c	/^	void (*printlog_handler)(const char *mess);$/;"	m	struct:__anon15	file:
progname	sem_main.c	/^static char *progname = NULL;$/;"	v	file:
progress_handler	userio.c	/^	void (*progress_handler)(unsigned int this, unsigned int total);$/;"	m	struct:__anon15	file:
prompt_for	ui.c	/^int prompt_for(const char *pr, PR_TYPE what, void *def_ret) {$/;"	f
pt	plot.c	/^	int pt, lt;$/;"	m	struct:__anon8	file:
ptr	parse.c	/^	void *ptr;$/;"	m	struct:__anon5	file:
pts	sample.c	/^	PTS *pts;$/;"	m	struct:__anon12	file:
push_bound	glvars.c	/^void push_bound(double value) {$/;"	f
push_d_vector	data.c	/^D_VECTOR *push_d_vector(double d, D_VECTOR *v) {$/;"	f
push_data_X	parse.c	/^static void push_data_X(DATA *d, int id) {$/;"	f	file:
push_edges_name	glvars.c	/^void push_edges_name(const char *name) {$/;"	f
push_gstat_progress_handler	userio.c	/^void push_gstat_progress_handler($/;"	f
push_marginal	parse.c	/^static void push_marginal(char *name, double value) {$/;"	f	file:
push_mask_name	glvars.c	/^void push_mask_name(const char *name) {$/;"	f
push_point	data.c	/^void push_point(DATA *d, const DPOINT *p) {$/;"	f
push_to_cloud	sem.c	/^static void push_to_cloud(SAMPLE_VGM *ev, double gamma, double dist,$/;"	f	file:
push_to_merge_table	data.c	/^int push_to_merge_table(DATA *d, int to_var, int col_this_X, int col_other_X) {$/;"	f
push_to_palet	palet.c	/^static PAL *push_to_palet(PAL *p, unsigned int rgb) {$/;"	f	file:
push_to_v	vario.c	/^void push_to_v(VARIOGRAM *v, const char *mod, double sill, double *range, $/;"	f
push_to_v_table	vario.c	/^void push_to_v_table(VARIOGRAM *v, double maxdist, int length, double *values,$/;"	f
push_variogram_model	vario.c	/^int push_variogram_model(VARIOGRAM *v, VGM_MODEL part) {$/;"	f
px	map2gd.c	/^int px = 0, interlace = 0, transparent = 1,$/;"	v
q_normal	random.c	/^double q_normal(double p) {$/;"	f
q_triangular	random.c	/^double q_triangular(double p) {$/;"	f
q_uniform	random.c	/^double q_uniform(double p) {$/;"	f
qtree_expand	nsearch.c	/^static QTREE_NODE *qtree_expand(const DPOINT *where, QTREE_NODE *root) {$/;"	f	file:
qtree_find_node	nsearch.c	/^static QTREE_NODE **qtree_find_node(const DPOINT *where, QTREE_NODE **p_node,$/;"	f	file:
qtree_free	nsearch.c	/^void qtree_free(QTREE_NODE *node) {$/;"	f
qtree_pop_point	nsearch.c	/^void qtree_pop_point(DPOINT *where, DATA *d) {$/;"	f
qtree_print	nsearch.c	/^void qtree_print(DATA *d) {$/;"	f
qtree_push	nsearch.c	/^static void qtree_push(DPOINT *where, QTREE_NODE **p_node, $/;"	f	file:
qtree_push_point	nsearch.c	/^void qtree_push_point(DATA *d, DPOINT *where) {$/;"	f
qtree_rebuild	nsearch.c	/^void qtree_rebuild(DATA *d) {$/;"	f
qtree_select	nsearch.c	/^int qtree_select(DPOINT *where, DATA *d) {$/;"	f
qtree_split_node	nsearch.c	/^static void qtree_split_node(QTREE_NODE *node, BBOX bbox, int rec_level) {$/;"	f	file:
qtree_zero_all_leaves	nsearch.c	/^static void qtree_zero_all_leaves(QTREE_NODE *node) {$/;"	f	file:
r	sample.c	/^	int r, c;$/;"	m	struct:__anon11	file:
r_normal	random.c	/^	double (*r_normal)(void);$/;"	m	struct:__anon10	file:
r_normal	random.c	/^double r_normal(void) {$/;"	f
r_triangular	random.c	/^double r_triangular(void) {$/;"	f
r_unif	random.c	/^	double (*r_unif)(void);$/;"	m	struct:__anon10	file:
r_uniform	random.c	/^double r_uniform(void) {$/;"	f
range	parse.c	/^static double range[NRANGEPARS], anis[5];$/;"	v	file:
read_T2	mapio.c	/^GRIDMAP *read_T2(GRIDMAP * m)$/;"	f
read_all_data	gstat.c	/^static void read_all_data(DATA **data, DATA *valdata, int n_vars) {$/;"	f	file:
read_arcgrid	mapio.c	/^static GRIDMAP *read_arcgrid(GRIDMAP * m)$/;"	f	file:
read_arcgrid_header	mapio.c	/^static int read_arcgrid_header(GRIDMAP * m, FILE * f)$/;"	f	file:
read_ascii_grid	mapio.c	/^static int read_ascii_grid(GRIDMAP * m, FILE * f, int first_line_in_buffer)$/;"	f	file:
read_csf	mapio.c	/^static GRIDMAP *read_csf(GRIDMAP * m)$/;"	f	file:
read_data_from_map	data.c	/^static int read_data_from_map(DATA *d) {$/;"	f	file:
read_data_line	data.c	/^static int read_data_line(FILE *f, char *line, DATA *d, DPOINT *current,$/;"	f	file:
read_double	read.c	/^int read_double(const char *s, double *d) {$/;"	f
read_eas_header	data.c	/^static int read_eas_header(FILE *infile, DATA *d, int ncols) {$/;"	f	file:
read_edges	polygon.c	/^void read_edges(void) $/;"	f
read_ermapper	mapio.c	/^static GRIDMAP *read_ermapper(GRIDMAP * m)$/;"	f	file:
read_ermapper_header	mapio.c	/^static int read_ermapper_header(GRIDMAP * m, FILE * f)$/;"	f	file:
read_ext_dbase	ext_dbase.c	/^void read_ext_dbase(DATA *d)$/;"	f
read_float	read.c	/^int read_float(const char *s, float *f) {$/;"	f
read_gdal	mapio.c	/^static GRIDMAP *read_gdal(GRIDMAP *m) {$/;"	f	file:
read_gmt	mapio.c	/^static GRIDMAP *read_gmt(GRIDMAP * m)$/;"	f	file:
read_grass	mapio.c	/^static GRIDMAP *read_grass(GRIDMAP * m)$/;"	f	file:
read_grass_data	data.c	/^static DATA *read_grass_data(DATA * d) {$/;"	f	file:
read_gslib	mapio.c	/^static GRIDMAP *read_gslib(GRIDMAP * m)$/;"	f	file:
read_gstat_data	data.c	/^DATA *read_gstat_data(DATA *d) {$/;"	f
read_idrisi32_header	mapio.c	/^static int read_idrisi32_header(GRIDMAP *m, const char *fname) {$/;"	f	file:
read_idrisi32_image	mapio.c	/^static GRIDMAP *read_idrisi32_image(GRIDMAP *m) { $/;"	f	file:
read_idrisi32_point_data	data.c	/^static int read_idrisi32_point_data(DATA *d, const char *fname) {$/;"	f	file:
read_idrisi32_point_header	data.c	/^static int read_idrisi32_point_header(DATA *d, const char *fname) {$/;"	f	file:
read_idrisi32_points	data.c	/^static int read_idrisi32_points(DATA *d) {$/;"	f	file:
read_idrisi_header	mapio.c	/^static int read_idrisi_header(GRIDMAP * m, const char *fname)$/;"	f	file:
read_idrisi_image	mapio.c	/^static GRIDMAP *read_idrisi_image(GRIDMAP * m)$/;"	f	file:
read_idrisi_point_data	data.c	/^static int read_idrisi_point_data(DATA *d, const char *fname) {$/;"	f	file:
read_idrisi_point_header	data.c	/^static int read_idrisi_point_header(DATA *d, const char *fname) {$/;"	f	file:
read_idrisi_points	data.c	/^static int read_idrisi_points(DATA *d) {$/;"	f	file:
read_int	read.c	/^int read_int(const char *s, int *i) {$/;"	f
read_long	read.c	/^int read_long(const char *s, long int *l) {$/;"	f
read_multiformat_bgrid	mapio.c	/^static int read_multiformat_bgrid(GRIDMAP * m, const char *fname, int swap)$/;"	f	file:
read_n_points	polygon.c	/^POLYGON read_n_points(FILE *f, int np) {$/;"	f
read_polygons	polygon.c	/^POLYGON *read_polygons(const char *filename, int *n_polys, double **iso_values) {$/;"	f
read_surfer	mapio.c	/^static GRIDMAP *read_surfer(GRIDMAP * m) {$/;"	f	file:
read_surfer_header	mapio.c	/^static int read_surfer_header(GRIDMAP * m, FILE * f)$/;"	f	file:
read_table	data.c	/^static DATA *read_table(DATA *d) {$/;"	f	file:
read_table	map2gd.c	/^static int read_table(char *s) {$/;"	f	file:
read_uint	read.c	/^int read_uint(const char *s, unsigned int *u) {$/;"	f
read_ulong	read.c	/^int read_ulong(const char *s, unsigned long *u) {$/;"	f
read_variogram	parse.c	/^int read_variogram(VARIOGRAM *v, const char *source) {$/;"	f
read_vector	parse.c	/^int read_vector(D_VECTOR *d, char *fname) {$/;"	f
record_closed	utils.c	/^static void record_closed(const FILE *f) {$/;"	f	file:
record_open	utils.c	/^static void record_open(const FILE *f, const char *name, const char *mode,$/;"	f	file:
record_removed	utils.c	/^static void record_removed(const char *name) {$/;"	f	file:
redraw_scr	ui.c	/^static int var_ids[2] = { -1, -1 }, redraw_scr = 0, window_nr = -1,$/;"	v	file:
register_pairs	sem.c	/^static void *register_pairs(void *pairs, unsigned long nh,$/;"	f	file:
relative_nugget	vario.c	/^double relative_nugget(VARIOGRAM *v) {$/;"	f
reml	reml.c	/^static int reml(VEC *Y, MAT *X, MAT **Vk, int n_k, int max_iter,$/;"	f	file:
reml_sills	reml.c	/^VARIOGRAM *reml_sills(DATA *data, VARIOGRAM *vp) {$/;"	f
remove_all	glvars.c	/^void remove_all(void) {$/;"	f
remove_at_exit	utils.c	/^	int nr, remove_at_exit;$/;"	m	struct:__anon18	file:
remove_id	glvars.c	/^int remove_id(const int id) {$/;"	f
remove_where_from_selection	xvalid.c	/^static void remove_where_from_selection(DATA *data, DPOINT *pt, int at0) {$/;"	f	file:
report_data	data.c	/^void report_data(const DATA *d) {$/;"	f
report_edges	polygon.c	/^void report_edges(void) {$/;"	f
report_xvalid	report.c	/^void report_xvalid(double *xdata, double *xpred, double *xdiff, double *xstd,$/;"	f
reset_anyway	block.c	/^int reset_anyway = 0;$/;"	v
reset_block_discr	block.c	/^void reset_block_discr(void) {$/;"	f
reset_gstat_errno	userio.c	/^void reset_gstat_errno(void) {$/;"	f
reset_lex	lex.c	/^static void reset_lex(void) {$/;"	f	file:
reset_parser	parse.c	/^static void reset_parser(void) {$/;"	f	file:
reset_variogram_parameters	getest.c	/^void reset_variogram_parameters(VARIOGRAM *v) {$/;"	f
resize_ev	sem.c	/^static void resize_ev(SAMPLE_VGM *ev, unsigned int size) {$/;"	f	file:
resize_pts_list	sample.c	/^static PTS_LIST *resize_pts_list(PTS_LIST *p, int new_max_size) {$/;"	f	file:
resize_strbuf	utils.c	/^STRING_BUFFER *resize_strbuf(STRING_BUFFER *b, unsigned int size) {$/;"	f
restore_data_list	msim.c	/^static void restore_data_list(DATA **data, int sim, int n_vars) {$/;"	f	file:
restore_data_sel	msim.c	/^void restore_data_sel(DATA **data, int sim, int n_vars) {$/;"	f
rng	random.c	/^static gsl_rng *rng = NULL;$/;"	v	file:
s2d	msim.c	/^	**s2d = NULL, $/;"	v	file:
s_gstat_error	s.c	/^void s_gstat_error(const char *mess, int level) {$/;"	f
s_gstat_printlog	s.c	/^void s_gstat_printlog(const char *mess) {$/;"	f
s_gstat_progress	s.c	/^void s_gstat_progress(unsigned int current, unsigned int total) {$/;"	f
s_gstat_warning	s.c	/^void s_gstat_warning(const char *mess) {$/;"	f
s_r_normal	s.c	/^double s_r_normal(void) {$/;"	f
s_r_uniform	s.c	/^double s_r_uniform(void) {$/;"	f
sample_main	sample.c	/^int sample_main(int argc, char *argv[]) {$/;"	f
sample_mean	stat.c	/^double sample_mean(double *list, int n) {$/;"	f
sample_std	stat.c	/^double sample_std(double *list, double mean, int n) {$/;"	f
sample_var	stat.c	/^double sample_var(double *list, double mean, int n) {$/;"	f
save_as	ui.c	/^int save_as(int key) {$/;"	f
save_sim	msim.c	/^void save_sim(DATA **data, DPOINT *where, int sim, int n_vars,$/;"	f
save_sim_strat	msim.c	/^void save_sim_strat(DATA *d, DPOINT *where, int sim, double value, int is_pt) {$/;"	f
save_simulations_to_ascii	msim.c	/^void save_simulations_to_ascii(const char *fname) {$/;"	f
save_simulations_to_maps	msim.c	/^void save_simulations_to_maps(GRIDMAP *mask) {$/;"	f
save_strcat	utils.c	/^void save_strcat(STRING_BUFFER *dest, const char *src) {$/;"	f
save_string	utils.c	/^const char *save_string(const char *msg) {$/;"	f
save_variogram_parameters	getest.c	/^void save_variogram_parameters(VARIOGRAM *v) {$/;"	f
sccsid	getopt.c	/^static char sccsid[] = "@(#)getopt.c    4.7 (Berkeley) 6\/27\/88";$/;"	v	file:
sd_vector	parse.c	/^static D_VECTOR *sd_vector = NULL;$/;"	v	file:
seed	random.c	/^static unsigned long int seed = 0;$/;"	v	file:
seed_is_in	s.c	/^static int seed_is_in = 0;$/;"	v	file:
segment_between_check	polygon.c	/^static int segment_between_check(PLOT_POINT a, PLOT_POINT b, PLOT_POINT c) {$/;"	f	file:
segment_cross_check	polygon.c	/^static unsigned int segment_cross_check(PLOT_POINT A, PLOT_POINT B, $/;"	f	file:
segment_parallel_check	polygon.c	/^static unsigned int segment_parallel_check(PLOT_POINT A, PLOT_POINT B, $/;"	f	file:
select_at	select.c	/^int select_at(DATA *d, DPOINT *where) {$/;"	f
select_ext_dbase	ext_dbase.c	/^int select_ext_dbase($/;"	f
select_qtree	select.c	/^static int select_qtree(DATA *d, DPOINT *where)$/;"	f	file:
sem_cov_ab	vario_io.c	/^double sem_cov_ab(VARIOGRAM *v, DPOINT *a, DPOINT *b, int sem)$/;"	f
sem_cov_blocks	vario_io.c	/^static double sem_cov_blocks(VARIOGRAM *v, DATA *a, DATA *b, int sem) {$/;"	f	file:
semivariogram	sem.c	/^static SAMPLE_VGM *semivariogram(DATA *d, SAMPLE_VGM *ev) {$/;"	f	file:
semivariogram_grid	sem.c	/^static SAMPLE_VGM *semivariogram_grid(DATA *d, SAMPLE_VGM *ev) {$/;"	f	file:
semivariogram_list	sem.c	/^static SAMPLE_VGM *semivariogram_list(DATA *d, SAMPLE_VGM *ev) {$/;"	f	file:
set_back_radius	select.c	58;"	d	file:
set_beta	msim.c	/^void set_beta(DATA **d, int sim, int n_vars, METHOD method) {$/;"	f
set_direction_values	direct.c	/^void set_direction_values(double a, double b, double t_h, double t_v) {$/;"	f
set_edges	glvars.c	/^POLYGON **set_edges(POLYGON **new_edges) {$/;"	f
set_gstat_error_handler	userio.c	/^void set_gstat_error_handler(void (*error_fn)(const char *message, int level)) {$/;"	f
set_gstat_log_file	userio.c	/^int set_gstat_log_file(FILE *f) {$/;"	f
set_gstat_log_handler	userio.c	/^void set_gstat_log_handler(void (*logprint)(const char *str)) {$/;"	f
set_gstat_progress_handler	userio.c	/^void set_gstat_progress_handler($/;"	f
set_gstat_warning_handler	userio.c	/^void set_gstat_warning_handler(void (*warning_fn)(const char *message)) {$/;"	f
set_key	plot.c	/^static int set_key(FILE *f, const VARIOGRAM *v, double min, double max) {$/;"	f	file:
set_lex_source	lex.c	/^void set_lex_source(const char *source, const char *fname) {$/;"	f
set_method	glvars.c	/^void set_method(METHOD m) {$/;"	f
set_mode	glvars.c	/^void set_mode(void) {$/;"	f
set_mouse_on	ui.c	/^void set_mouse_on(void) {$/;"	f
set_mv_double	utils.c	/^void set_mv_double(double *d) {$/;"	f
set_mv_float	utils.c	/^void set_mv_float(float *f) {$/;"	f
set_n_edges_polys	glvars.c	/^int *set_n_edges_polys(int *n) {$/;"	f
set_norm_fns	data.c	/^void set_norm_fns(DATA *d) {$/;"	f
set_output	ui.c	/^void set_output(int key) {$/;"	f
set_rng_functions	random.c	/^void set_rng_functions($/;"	f
set_seed	random.c	/^void set_seed(unsigned long int i) {$/;"	f
setup_beta	msim.c	/^void setup_beta(DATA **d, int n_vars, int n_sim) {$/;"	f
setup_command	ui.c	/^void setup_command(void) {$/;"	f
setup_data_minmax	data.c	/^void setup_data_minmax(DATA *d) {$/;"	f
setup_meschach_error_handler	userio.c	/^void setup_meschach_error_handler(int using_R) {$/;"	f
setup_poly_method	glvars.c	/^DATA *setup_poly_method(void) {$/;"	f
setup_poly_minmax	polygon.c	/^void setup_poly_minmax(POLYGON *pl) {$/;"	f
setup_polynomial_X	data.c	/^void setup_polynomial_X(DATA *d) {$/;"	f
setup_valdata_X	glvars.c	/^void setup_valdata_X(DATA *d) {$/;"	f
short	parse.c	304;"	d	file:
show_plot	ui.c	/^void show_plot(int key) {$/;"	f
simulate_mvn	sim.c	/^static void simulate_mvn(const double *est, VEC *result, const int *is_datum) {$/;"	f	file:
simulate_uniform	sim.c	/^static void simulate_uniform(double *est, VEC *result, int orc) {$/;"	f	file:
size	sample.c	/^	int max_size, size;$/;"	m	struct:__anon12	file:
sizeof_ct	mapio.c	/^static unsigned int sizeof_ct(CellType ct)$/;"	f	file:
spC	gls.c	/^	SPMAT *spC;    \/* sparse version of C *\/$/;"	m	struct:__anon3	file:
spC	gls.c	/^	void *spC;$/;"	m	struct:__anon3	file:
sp_logoutput	gls.c	/^void    sp_logoutput(SPMAT *A)$/;"	f
sprint_cmd	writecmd.c	/^const char *sprint_cmd(void) {$/;"	f
sprint_glvars	writecmd.c	/^const char *sprint_glvars(int anyway) {$/;"	f
sprint_variogram	vario.c	/^const char *sprint_variogram(const VARIOGRAM *v, int verbose) {$/;"	f
start	utils.c	/^static time_t start;$/;"	v	file:
start_random_number	random.c	/^static void start_random_number (int seed_a, int seed_b)$/;"	f	file:
start_ui	ui.c	/^int start_ui(void) {$/;"	f
start_up	random.c	/^static char start_up[100];$/;"	v	file:
stats	stat.c	/^int stats(char *name, int silent, double q) {$/;"	f
status	utils.c	/^	FILE_STATUS status;$/;"	m	struct:__anon18	file:
store_argv	utils.c	/^char *store_argv(int argc, char *argv[]) {$/;"	f
store_radius	select.c	57;"	d	file:
strata_min	predict.c	/^int strata_min;$/;"	v
strcat_tm	vario.c	/^static void strcat_tm(char *cp, ANIS_TM *tm) {$/;"	f	file:
stream_name	utils.c	/^static const char *stream_name(const FILE *f) {$/;"	f	file:
string_casecmp	utils.c	/^int string_casecmp(const char *a, const char *b) {$/;"	f
string_cat	utils.c	/^const char *string_cat(const char *s, const char *t) {$/;"	f
string_file	utils.c	/^char *string_file(const char *fname) {$/;"	f
string_prompt	utils.c	/^char *string_prompt(const char *prompt) {$/;"	f
sub_bbox	nsearch.c	/^static BBOX sub_bbox(const BBOX bbox, int index) {$/;"	f	file:
sval	parse.c	/^	char *sval;$/;"	m	union:YYSTYPE	file:
swap_floats	mapio.c	/^static void swap_floats(unsigned char *b, unsigned int n)$/;"	f	file:
swap_multiformat	mapio.c	/^static void swap_multiformat(unsigned char *b, unsigned int m,$/;"	f	file:
table	map2gd.c	/^float min, max, interval, *table; $/;"	v
table_read	map2gd.c	/^	min_set = 0, max_set = 0, table_read = 0, nc = 0, nice_legend = 0,$/;"	v
table_size	msim.c	/^	table_size = 0, \/* offset strata table size *\/$/;"	v	file:
tell	getopt.c	37;"	d	file:
term_name	plot.c	/^	char *term_name, *term_opt, *gamma_str, *distance_str;$/;"	m	struct:__anon8	file:
term_opt	plot.c	/^	char *term_name, *term_opt, *gamma_str, *distance_str;$/;"	m	struct:__anon8	file:
text	ui.c	/^	char *text, **help, *entry;$/;"	m	struct:__anon14	file:
text_a	ui.c	/^static char *text_a[MAX_OPTION] = {$/;"	v	file:
text_b	ui.c	/^static char *text_b[MAX_OPTION] = {$/;"	v	file:
ticks	map2gd.c	/^	nc_max = 0, n_table = 0, nclass = 16, draw_map_box = 0, ticks = 0;$/;"	v
time_seed	random.c	/^static unsigned long int time_seed(void) {$/;"	f	file:
title	map2gd.c	/^char colour_table[256] = "", *title = NULL, tmp_str[256] = "";$/;"	v
tmp_str	map2gd.c	/^char colour_table[256] = "", *title = NULL, tmp_str[256] = "";$/;"	v
toggle_model	ui.c	/^VGM_MODEL_TYPE toggle_model(int i, VGM_MODEL_TYPE m) {$/;"	f
tol_hor	direct.c	/^	tol_hor = PI, tol_ver = PI,$/;"	v	file:
tol_ver	direct.c	/^	tol_hor = PI, tol_ver = PI,$/;"	v	file:
trace_matrix	reml.c	/^static double trace_matrix(MAT *m) {$/;"	f	file:
transform_data	data.c	/^static void transform_data(DATA *d) {$/;"	f	file:
transform_norm	vario.c	/^double transform_norm(const ANIS_TM *tm, double dx, double dy, double dz) {$/;"	f
transparent	map2gd.c	/^int px = 0, interlace = 0, transparent = 1,$/;"	v
type	utils.c	/^	FILE_TYPE type;$/;"	m	struct:__anon18	file:
u	random.c	/^static double u[STATE_SIZE];$/;"	v	file:
unlink_ext_dbase	ext_dbase.c	/^void unlink_ext_dbase(DATA *d) {$/;"	f
unput	lex.c	207;"	d	file:
unput	lex.c	596;"	d	file:
unput	lex.c	602;"	d	file:
unquote	lex.c	/^static char *unquote(const char *txt) {$/;"	f	file:
update_variogram	vario.c	/^void update_variogram(VARIOGRAM *vp) {$/;"	f
use_pipe	ui.c	/^int wind = 0, cmd_written = 0, use_pipe = 0;$/;"	v
user_palette	palet.c	/^static PAL *user_palette = NULL;$/;"	v	file:
uval	parse.c	/^	unsigned int uval;$/;"	m	union:YYSTYPE	file:
v	ext_dbase.c	/^  float x,y,v;$/;"	m	struct:__anon1	file:
v	parse.c	/^static VARIOGRAM *v = NULL;$/;"	v	file:
v	ui.c	/^static VARIOGRAM *v = NULL, *v_tmp = NULL;$/;"	v	file:
v_bin	data.c	/^double v_bin(double mu) {$/;"	f
v_identity	data.c	/^double v_identity(double mu) {$/;"	f
v_logoutput	lm.c	/^void v_logoutput(VEC * x)$/;"	f
v_models	vario.c	/^const V_MODEL v_models[] = { \/* the variogram model ``data base'': *\/$/;"	v
v_mu	data.c	/^double v_mu(double mu) {$/;"	f
v_mu2	data.c	/^double v_mu2(double mu) {$/;"	f
v_mu3	data.c	/^double v_mu3(double mu) {$/;"	f
v_tmp	ui.c	/^static VARIOGRAM *v = NULL, *v_tmp = NULL;$/;"	v	file:
val_data	predict.c	/^static DATA *val_data = NULL;$/;"	v	file:
valdata	glvars.c	/^static DATA *valdata = NULL;$/;"	v	file:
valid_direction	direct.c	/^double valid_direction(DPOINT *a, DPOINT *b, int symmetric, const DATA *d) {$/;"	f
valid_distance	sem.c	/^static double valid_distance(DPOINT *a, DPOINT *b, double max, $/;"	f	file:
var_ids	ui.c	/^static int var_ids[2] = { -1, -1 }, redraw_scr = 0, window_nr = -1,$/;"	v	file:
vario	vario.c	/^int vario(int argc, char **argv) {$/;"	f
vector_only	parse.c	/^	vector_only = 0, allow_vector_only = 0;$/;"	v	file:
verify_data	parse.c	/^static void verify_data(DATA *d) { \/* declaration : contents *\/$/;"	f	file:
vgm	glvars.c	/^static VARIOGRAM **vgm = NULL;$/;"	v	file:
vgm_init_block_values	vario.c	/^void vgm_init_block_values(VARIOGRAM *v) {$/;"	f
vgm_model	ui.c	/^void vgm_model(int key) {$/;"	f
vgm_pars	getest.c	/^static double *vgm_pars = NULL;$/;"	v	file:
vgm_type	ui.c	/^SAMPLE_VGM_TYPE vgm_type = NOTSPECIFIED;$/;"	v
vgm_type_str	vario.c	/^const char *vgm_type_str[] = { $/;"	v
warning_handler	userio.c	/^	void (*warning_handler)(const char *mess);$/;"	m	struct:__anon15	file:
warning_message	userio.c	/^	*warning_message = NULL;$/;"	v	file:
warning_msg	ui.c	/^	*warning_msg = NULL;$/;"	v	file:
warning_set	ui.c	/^	warning_set = 0, curses_open = 0;$/;"	v	file:
what	parse.c	/^	} what;$/;"	m	struct:__anon5	typeref:enum:__anon5::__anon6	file:
what	ui.c	/^static enum { VGM = 0, PRED, XVALID, CONDSIM } what = VGM;$/;"	v	typeref:enum:__anon13	file:
what_cmp	pqueue.c	/^int what_cmp(const Q_ELEMENT_WHAT *a, const Q_ELEMENT_WHAT *b) {$/;"	f
what_is_file	utils.c	/^static FILE_TYPE what_is_file(const FILE *f) {$/;"	f	file:
what_is_outfile	glvars.c	/^const char *what_is_outfile(int i) {$/;"	f
which_identifier	glvars.c	/^int which_identifier(const char *id) {$/;"	f
which_octant	select.c	/^static int which_octant(DPOINT *where, DPOINT *p, int mode) {$/;"	f	file:
which_point	msim.c	/^static DPOINT *which_point(DATA *d, DPOINT *where) {$/;"	f	file:
which_variogram_model	vario.c	/^VGM_MODEL_TYPE which_variogram_model(const char *m) {$/;"	f
wind	ui.c	/^int wind = 0, cmd_written = 0, use_pipe = 0;$/;"	v
window_nr	ui.c	/^static int var_ids[2] = { -1, -1 }, redraw_scr = 0, window_nr = -1,$/;"	v	file:
winds	ui.c	/^static const char *winds[N_WIND] = { "N","NE","E","SE","S","SW","W","NW" },$/;"	v	file:
wls_fit	fit.c	/^static void wls_fit(VARIOGRAM *vp) {$/;"	f	file:
write_T2	mapio.c	/^static GRIDMAP *write_T2(GRIDMAP * m)$/;"	f	file:
write_arcgrid	mapio.c	/^static GRIDMAP *write_arcgrid(GRIDMAP * m)$/;"	f	file:
write_arcgrid_header	mapio.c	/^static int write_arcgrid_header(GRIDMAP * m, FILE * f)$/;"	f	file:
write_ascii_grid	mapio.c	/^static void write_ascii_grid(GRIDMAP * m, FILE * f, int as_rows)$/;"	f	file:
write_ascii_header	report.c	/^static void write_ascii_header(FILE *out_file, DATA *data, int n_outfl) {$/;"	f	file:
write_binary_grid	mapio.c	/^static void write_binary_grid(GRIDMAP * m, const char *fname, int swap)$/;"	f	file:
write_csf	mapio.c	/^static GRIDMAP *write_csf(GRIDMAP * m)$/;"	f	file:
write_ermapper	mapio.c	/^static GRIDMAP *write_ermapper(GRIDMAP * m)$/;"	f	file:
write_ermapper_header	mapio.c	/^static void write_ermapper_header(GRIDMAP * m, FILE * fp)$/;"	f	file:
write_error	mapio.c	/^static GRIDMAP *write_error(GRIDMAP * m)$/;"	f	file:
write_fx	fit.c	/^static void write_fx(FILE *f, VARIOGRAM *v) {$/;"	f	file:
write_gdal	mapio.c	/^static GRIDMAP *write_gdal(GRIDMAP *m) {$/;"	f	file:
write_gmt	mapio.c	/^static GRIDMAP *write_gmt(GRIDMAP * m)$/;"	f	file:
write_gnuplot_binary	mapio.c	/^static GRIDMAP *write_gnuplot_binary(GRIDMAP * m)$/;"	f	file:
write_grass	mapio.c	/^static GRIDMAP *write_grass(GRIDMAP * m)$/;"	f	file:
write_gslib	mapio.c	/^static GRIDMAP *write_gslib(GRIDMAP * m)$/;"	f	file:
write_idrisi	mapio.c	/^static GRIDMAP *write_idrisi(GRIDMAP * m)$/;"	f	file:
write_idrisi32	mapio.c	/^static GRIDMAP *write_idrisi32(GRIDMAP *m) {    $/;"	f	file:
write_idrisi32_header	mapio.c	/^static int write_idrisi32_header(GRIDMAP *m, const char *fname) {$/;"	f	file:
write_idrisi_header	mapio.c	/^static int write_idrisi_header(GRIDMAP * m, const char *fname) {$/;"	f	file:
write_output	predict.c	/^static void write_output(double *est, PRED_AT w, DPOINT *here,$/;"	f	file:
write_points	report.c	/^void write_points(const char *fname, DATA *d, DPOINT *where, double *est,$/;"	f
write_surfer	mapio.c	/^static GRIDMAP *write_surfer(GRIDMAP * m)$/;"	f	file:
x	ext_dbase.c	/^  float x,y,v;$/;"	m	struct:__anon1	file:
x	sample.c	/^	float x, y;  \/* x and y coordinate in [0,1]x[0,1] area *\/$/;"	m	struct:__anon11	file:
xy_ratio	sample.c	/^	float xy_ratio; \/* dx\/dy *\/$/;"	m	struct:__anon12	file:
y	ext_dbase.c	/^  float x,y,v;$/;"	m	struct:__anon1	file:
y	gls.c	/^	VEC *y,        \/* measurement vector *\/$/;"	m	struct:__anon3	file:
y	sample.c	/^	float x, y;  \/* x and y coordinate in [0,1]x[0,1] area *\/$/;"	m	struct:__anon11	file:
yy_File_name	lex.c	/^static const char *yy_File_name = NULL;$/;"	v	file:
yy_Lexpos	lex.c	/^static int yy_Lexpos = 0, yy_Posafternl = 1, My_yy_lineno = 1,$/;"	v	file:
yy_Posafternl	lex.c	/^static int yy_Lexpos = 0, yy_Posafternl = 1, My_yy_lineno = 1,$/;"	v	file:
yy_Source	lex.c	/^static const char *yy_Source = NULL, *lastnl = NULL;$/;"	v	file:
yy_accept	lex.c	/^static yyconst flex_int16_t yy_accept[44] =$/;"	v	file:
yy_at_bol	lex.c	/^	int yy_at_bol;$/;"	m	struct:yy_buffer_state	file:
yy_base	lex.c	/^static yyconst flex_int16_t yy_base[53] =$/;"	v	file:
yy_bs_column	lex.c	/^    int yy_bs_column; \/**< The column count. *\/$/;"	m	struct:yy_buffer_state	file:
yy_bs_lineno	lex.c	/^    int yy_bs_lineno; \/**< The line count. *\/$/;"	m	struct:yy_buffer_state	file:
yy_buf_pos	lex.c	/^	char *yy_buf_pos;		\/* current position in input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_buf_size	lex.c	/^	yy_size_t yy_buf_size;$/;"	m	struct:yy_buffer_state	file:
yy_buffer_stack	lex.c	/^static YY_BUFFER_STATE * yy_buffer_stack = 0; \/**< Stack as an array. *\/$/;"	v	file:
yy_buffer_stack_max	lex.c	/^static size_t yy_buffer_stack_max = 0; \/**< capacity of stack. *\/$/;"	v	file:
yy_buffer_stack_top	lex.c	/^static size_t yy_buffer_stack_top = 0; \/**< index of top of stack. *\/$/;"	v	file:
yy_buffer_state	lex.c	/^struct yy_buffer_state$/;"	s	file:
yy_buffer_status	lex.c	/^	int yy_buffer_status;$/;"	m	struct:yy_buffer_state	file:
yy_c_buf_p	lex.c	/^static char *yy_c_buf_p = (char *) 0;$/;"	v	file:
yy_ch_buf	lex.c	/^	char *yy_ch_buf;		\/* input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_chk	lex.c	/^static yyconst flex_int16_t yy_chk[103] =$/;"	v	file:
yy_create_buffer	lex.c	8;"	d	file:
yy_def	lex.c	/^static yyconst flex_int16_t yy_def[53] =$/;"	v	file:
yy_delete_buffer	lex.c	9;"	d	file:
yy_did_buffer_switch_on_eof	lex.c	/^static int yy_did_buffer_switch_on_eof;$/;"	v	file:
yy_ec	lex.c	/^static yyconst flex_int32_t yy_ec[256] =$/;"	v	file:
yy_fatal_error	lex.c	/^static void yy_fatal_error (yyconst char* msg )$/;"	f	file:
yy_fill_buffer	lex.c	/^	int yy_fill_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_flex_debug	lex.c	10;"	d	file:
yy_flex_strlen	lex.c	/^static int yy_flex_strlen (yyconst char * s )$/;"	f	file:
yy_flex_strncpy	lex.c	/^static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )$/;"	f	file:
yy_flush_buffer	lex.c	12;"	d	file:
yy_get_next_buffer	lex.c	/^static int yy_get_next_buffer (void)$/;"	f	file:
yy_get_previous_state	lex.c	/^    static yy_state_type yy_get_previous_state (void)$/;"	f	file:
yy_hold_char	lex.c	/^static char yy_hold_char;$/;"	v	file:
yy_init	lex.c	/^static int yy_init = 0;		\/* whether we need to initialize *\/$/;"	v	file:
yy_init_buffer	lex.c	11;"	d	file:
yy_init_globals	lex.c	/^static int yy_init_globals (void)$/;"	f	file:
yy_input_file	lex.c	/^	FILE *yy_input_file;$/;"	m	struct:yy_buffer_state	file:
yy_is_interactive	lex.c	/^	int yy_is_interactive;$/;"	m	struct:yy_buffer_state	file:
yy_is_our_buffer	lex.c	/^	int yy_is_our_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_last_accepting_cpos	lex.c	/^static char *yy_last_accepting_cpos;$/;"	v	file:
yy_last_accepting_state	lex.c	/^static yy_state_type yy_last_accepting_state;$/;"	v	file:
yy_load_buffer_state	lex.c	13;"	d	file:
yy_meta	lex.c	/^static yyconst flex_int32_t yy_meta[16] =$/;"	v	file:
yy_n_chars	lex.c	/^	int yy_n_chars;$/;"	m	struct:yy_buffer_state	file:
yy_n_chars	lex.c	/^static int yy_n_chars;		\/* number of characters read into yy_ch_buf *\/$/;"	v	file:
yy_new_buffer	lex.c	336;"	d	file:
yy_nxt	lex.c	/^	flex_int32_t yy_nxt;$/;"	m	struct:yy_trans_info	file:
yy_nxt	lex.c	/^static yyconst flex_int16_t yy_nxt[103] =$/;"	v	file:
yy_reduce_print	parse.c	/^yy_reduce_print (YYSTYPE *yyvsp, int yyrule)$/;"	f	file:
yy_set_bol	lex.c	348;"	d	file:
yy_set_interactive	lex.c	338;"	d	file:
yy_size_t	lex.c	/^typedef size_t yy_size_t;$/;"	t	file:
yy_stack_print	parse.c	/^yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)$/;"	f	file:
yy_start	lex.c	/^static int yy_start = 0;	\/* start state number *\/$/;"	v	file:
yy_state_type	lex.c	/^typedef int yy_state_type;$/;"	t	file:
yy_switch_to_buffer	lex.c	14;"	d	file:
yy_symbol_print	parse.c	/^yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)$/;"	f	file:
yy_symbol_value_print	parse.c	/^yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)$/;"	f	file:
yy_trans_info	lex.c	/^struct yy_trans_info$/;"	s	file:
yy_try_NUL_trans	lex.c	/^    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )$/;"	f	file:
yy_verify	lex.c	/^	flex_int32_t yy_verify;$/;"	m	struct:yy_trans_info	file:
yyalloc	lex.c	23;"	d	file:
yyalloc	parse.c	/^union yyalloc$/;"	u	file:
yychar	parse.c	/^int yychar;$/;"	v
yychar	parse.c	71;"	d	file:
yycheck	parse.c	/^static const yytype_uint8 yycheck[] =$/;"	v	file:
yyclearin	parse.c	925;"	d	file:
yyconst	lex.c	125;"	d	file:
yyconst	lex.c	127;"	d	file:
yydebug	parse.c	/^int yydebug;$/;"	v
yydebug	parse.c	72;"	d	file:
yydefact	parse.c	/^static const yytype_uint8 yydefact[] =$/;"	v	file:
yydefgoto	parse.c	/^static const yytype_int16 yydefgoto[] =$/;"	v	file:
yydestruct	parse.c	/^yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)$/;"	f	file:
yyerrok	parse.c	924;"	d	file:
yyerror	parse.c	69;"	d	file:
yyfree	lex.c	25;"	d	file:
yyin	lex.c	15;"	d	file:
yyinput	lex.c	/^    static int yyinput (void)$/;"	f	file:
yyleng	lex.c	16;"	d	file:
yyless	lex.c	1821;"	d	file:
yyless	lex.c	1822;"	d	file:
yyless	lex.c	194;"	d	file:
yylex	lex.c	17;"	d	file:
yylex	parse.c	68;"	d	file:
yylineno	lex.c	18;"	d	file:
yylval	lex.c	561;"	d	file:
yylval	parse.c	/^YYSTYPE yylval;$/;"	v
yylval	parse.c	70;"	d	file:
yymore	lex.c	508;"	d	file:
yynerrs	parse.c	/^int yynerrs;$/;"	v
yynerrs	parse.c	73;"	d	file:
yyout	lex.c	19;"	d	file:
yypact	parse.c	/^static const yytype_int16 yypact[] =$/;"	v	file:
yyparse	parse.c	/^yyparse (void *YYPARSE_PARAM)$/;"	f
yyparse	parse.c	67;"	d	file:
yypgoto	parse.c	/^static const yytype_int16 yypgoto[] =$/;"	v	file:
yyprhs	parse.c	/^static const yytype_uint16 yyprhs[] =$/;"	v	file:
yyr1	parse.c	/^static const yytype_uint8 yyr1[] =$/;"	v	file:
yyr2	parse.c	/^static const yytype_uint8 yyr2[] =$/;"	v	file:
yyrealloc	lex.c	24;"	d	file:
yyrestart	lex.c	20;"	d	file:
yyrhs	parse.c	/^static const yytype_int8 yyrhs[] =$/;"	v	file:
yyrline	parse.c	/^static const yytype_uint16 yyrline[] =$/;"	v	file:
yyss_alloc	parse.c	/^  yytype_int16 yyss_alloc;$/;"	m	union:yyalloc	file:
yystos	parse.c	/^static const yytype_uint8 yystos[] =$/;"	v	file:
yystpcpy	parse.c	/^yystpcpy (char *yydest, const char *yysrc)$/;"	f	file:
yystpcpy	parse.c	1223;"	d	file:
yystrlen	parse.c	/^yystrlen (const char *yystr)$/;"	f	file:
yystrlen	parse.c	1200;"	d	file:
yystype	parse.c	292;"	d	file:
yysyntax_error	parse.c	/^yysyntax_error (char *yyresult, int yystate, int yychar)$/;"	f	file:
yytable	parse.c	/^static const yytype_uint8 yytable[] =$/;"	v	file:
yyterminate	lex.c	755;"	d	file:
yytext	lex.c	21;"	d	file:
yytext_ptr	lex.c	373;"	d	file:
yytname	parse.c	/^static const char *const yytname[] =$/;"	v	file:
yytnamerr	parse.c	/^yytnamerr (char *yyres, const char *yystr)$/;"	f	file:
yytokentype	parse.c	/^   enum yytokentype {$/;"	g	file:
yytoknum	parse.c	/^static const yytype_uint16 yytoknum[] =$/;"	v	file:
yytranslate	parse.c	/^static const yytype_uint8 yytranslate[] =$/;"	v	file:
yytype_int16	parse.c	/^typedef YYTYPE_INT16 yytype_int16;$/;"	t	file:
yytype_int16	parse.c	/^typedef short int yytype_int16;$/;"	t	file:
yytype_int8	parse.c	/^typedef YYTYPE_INT8 yytype_int8;$/;"	t	file:
yytype_int8	parse.c	/^typedef short int yytype_int8;$/;"	t	file:
yytype_int8	parse.c	/^typedef signed char yytype_int8;$/;"	t	file:
yytype_uint16	parse.c	/^typedef YYTYPE_UINT16 yytype_uint16;$/;"	t	file:
yytype_uint16	parse.c	/^typedef unsigned short int yytype_uint16;$/;"	t	file:
yytype_uint8	parse.c	/^typedef YYTYPE_UINT8 yytype_uint8;$/;"	t	file:
yytype_uint8	parse.c	/^typedef unsigned char yytype_uint8;$/;"	t	file:
yyunput	lex.c	/^    static void yyunput (int c, register char * yy_bp )$/;"	f	file:
yyvs_alloc	parse.c	/^  YYSTYPE yyvs_alloc;$/;"	m	union:yyalloc	file:
yywrap	lex.c	22;"	d	file:
zero_int2enum	vario.c	/^DO_AT_ZERO zero_int2enum(int zero) {$/;"	f
zero_sel_dist2	select.c	/^static void zero_sel_dist2(DATA *d) {$/;"	f	file:
zero_shift	vario.c	/^DO_AT_ZERO zero_shift(DO_AT_ZERO now, int next) {$/;"	f
zero_weights_count	lm.c	/^static int zero_weights_count(LM *lm) {$/;"	f	file:
